///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2023 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Helidon Níma Testing
:h1Prefix: Níma
:pagename: Helidon Níma Testing
:description: Testing in Helidon Níma
:keywords: helidon, nima, test, testing, junit
:feature-name: Helidon Níma Testing Framework
:rootdir: {docdir}/..

== Contents

- <<Overview, Overview>>
- <<Maven Coordinates, Maven Coordinates>>
- <<Usage, Usage>>
- <<Examples, Examples>>
- <<Additional Information, Additional Information>>
- <<Reference, Reference>>

== Overview

Helidon provides built-in test support for Helidon Níma testing with JUnit5.

include::{rootdir}/includes/dependencies.adoc[]
[source,xml]
----
<dependency>
    <groupId>io.helidon.nima.testing.junit5</groupId>
    <artifactId>helidon-nima-testing-junit5-webserver</artifactId>
    <scope>test</scope>
</dependency>
----

== Usage
Helidon provides a rich set of extensions based on JUnit5 for Helidon Níma testing. It can be done with automatic server start-up, configuration, and shutdown, as well as testing without full server start-up with `DrirectClient`, when no real sockets are created.

== API

There are two main annotations that can be used to test Níma server.

* `@ServerTest` is an integration test annotation that starts the server (opens ports) and provides client injection pre-configured for the server port(s).
* `@RoutingTest` is a unit test annotation that does not start the server and does not open ports but provides a direct client (with the same API as the usual network client) to test routing.

Additional annotation `@Socket` can be used to qualify the injection of parameters into test constructors or methods, such as to obtain a client configured for the named socket.

FIXME: Reused from internal docs:

The following table lists supported types of parameters for `@SetUpRoute` annotated methods. Such methods MUST be static
and may have any name. `@SetUpRoute` annotation has `value` with socket name (to customize the setup for a different socket).

- Parameter type - supported class of a parameter
- Annotation - which annotation(s) support this parameter
- Modules - which Níma extension modules support this signature

.Parameters for `@SetUpRoute` annotated methods.
|===
|Parameter Type |Annotation |Modules |Notes

|`HttpRouting.Builder`
|`@ServerTest`, `@RoutingTest`
|
|

|`HttpRules`
|`@ServerTest`, `@RoutingTest`
|
|Same as `HttpRouting.Builder`, only routing setup

|`Router.RouterBuilder<?>`
|`@ServerTest`, `@RoutingTest`
|
|

|`SocketListener.Builder`
|`@ServerTest`
|
|

|`WebSocketRouting.Builder`
|`@ServerTest`, `@RoutingTest`
|websocket
|

|===

In addition, a static method annotated with `@SetUpServer` can be defined for `@ServerTest`, which has a single parameter of `WebServer.Builder`.

The following table lists injectable types (through constructor or method injection).

- Type - type that can be injected
- Socket? - if checked, you can use `@Socket` annotation to obtain a value specific to that named socket
- Annotation - which annotation(s) support this injection
- Modules - which Níma extension modules support this injection
- Notes - additional details

.Injectable types.
|===
|Type |Socket? |Annotation |Modules |Notes
|`WebServer`
|
|`@ServerTest`
|
|Server instance (already started)

|`URI`
|x
|`@ServerTest`
|
|URI pointing to a port of the webserver

|`SocketHttpClient`
|x
|`@ServerTest`
|
|Client that allows sending of anything,to test bad request and such.

|`Http1Client`
|x
|`@ServerTest`
|
|

|`DirectClient`
|x
|`@RoutingTest`
|
|Implements `Http1Client` API

|`WsClient`
|x
|`@ServerTest`
|websocket
|

|`DirectWsClient`
|x
|`@RoutingTest`
|websocket
|Implements `WsClient` API

|===


Extensions can enhance the features for the module `helidon-nima-testing-junit5-webserver` to support additional protocols.


== Examples

We can create the following test if we want to test our server to return the correct response.

.Basic Helidon Níma test framework usage.
[source, java]
----
@ServerTest     <1>
class IntegrationTest {

    private final Http1Client client;

    protected IntegrationTest(Http1Client client) { <2>
        this.client = client;
    }

    @SetUpRoute <3>
    static void routing(HttpRouting.Builder builder) {
        QuickstartMain.routing(builder);
    }

    @Test <4>
    void testRootRoute() {
        try (Http1ClientResponse response = client.get("/greet")
                .request()) {   <5>

            assertThat(response.status(), is(Http.Status.OK_200));  <6>
        }
    }
}
----
<1> Use `@ServerTest` to trigger the testing framework;
<2> Inject `Http1Client` for the test;
<3> SetUp routing for the test;
<4> Regular `JUnit` test method;
<5> Call the `client` to obtain server response;
<6> Perform necessary assertions;

To trigger the framework starting and configuring Níma server, the testing class should be annotated with `@ServerTest` annotation.

In this test, the `Http1Client` is used, which means that the framework will take care of creating, configuring, and injecting this object as a parameter to the constructor.

To set up routing, a static method annotated with `@SetUpRoute` is present. The framework uses this method to inject the configured routing to the subject of testing – in the current case `Quickstart` application.

As everything above is performed by the testing framework, regular unit tests can be done. When all tests are completed, the testing framework will shut down the Níma server.

=== Routing tests

If there is no need to set up and run a server, a `DirectClient` can be used. It is a testing client that bypasses HTTP transport and directly invokes the router.

.Routing test using `@RoutingTest` and `DirectClient`.
[source, java]
----
@RoutingTest    <1>
class RoutingTest {

    private final Http1Client client;

    protected RoutingTest(DirectClient client) { <2>
        this.client = client;
    }

    @SetUpRoute <3>
    static void routing(HttpRouting.Builder builder) {
        QuickstartMain.routing(builder);
    }

    @Test <4>
    void testRootRoute() {
        try (Http1ClientResponse response = client.get("/greet")
                .request()) {   <5>

            JsonObject json = response.as(JsonObject.class);    <6>
            assertThat(json.getString("message"), is("Hello World!"));
        }
    }
}
----
<1> Use `@RoutingTest` to trigger the testing framework;
<2> Inject `DirectClient` for the test;
<3> SetUp routing for the test;
<4> A regular `JUnit` test method;
<5> Call the `client` to obtain server response;
<6> Perform necessary assertions;

If only routing tests are required, this is a "lighter" way of testing since the framework will not configure and run the full Níma server. This way, no real ports will be opened. All the communication will be done through `DirectClient` which makes the tests very effective.

It is required to annotate the test class with `@RoutingTest` annotation to trigger the server to do the configuration. Thus, it will inject the `DirectClient`, which can then be used in unit tests.

Routing is configured the same way as in full server testing using the `@SetUpRoute` annotation.

== Additional Information

=== WebSocket Testing

In case WebSocket testing is required, there is an additional module for this. It is necessary to include the following Maven dependency to Project's pom file:

[source,xml]
----
<dependency>
    <groupId>io.helidon.nima.testing.junit5</groupId>
    <artifactId>helidon-nima-testing-junit5-websocket</artifactId>
    <scope>test</scope>
</dependency>
----


=== WebSocket Testing Example

WebSocket Testing extension adds support for routing configuration and injection of WebSocket related artifacts, such as `WebSockets` as well `DirectWsClient` in Helidon Níma unit tests.

.WebSocket sample test.
[source,java]
----
@ServerTest
class WsSocketTest {

    private static final ServerSideListener WS_LISTENER = new ServerSideListener();

    private final WsClient wsClient;    <1>

    protected WsSocketTest(WsClient wsClient) {
        this.wsClient = wsClient;
    }

    @SetUpRoute
    static void routing(WsRouting.Builder ws) { <2>
        ws.endpoint("/testWs", WS_LISTENER);
    }

    @Test
    void testWsEndpoint() { <3>
        WS_LISTENER.reset();

        ClientSideListener clientListener = new ClientSideListener();
        wsClient.connect("/testWs", clientListener);    <4>

        assertThat(clientListener.message, is("ws"));   <5>
    }
}
----
<1> Declare `WsClient` and later inject it in the constructor;
<2> Using `@SetUpRoute` create WebSocket routing and assign a serverside listener;
<3> Test the WebSocket endpoint using regular `@Test` annotation;
<4> Create and assign clientside listener;
<5> Check if the received message is correct;


FIXME: not sure we need this, maybe as popup?

WebSocket `ClientSideListener` is a helper class implementing `WsListener`, is very simple and looks this way:

.`ClientSideListener` helper class.
[source,java]
----
private static class ClientSideListener implements WsListener {
    private final CountDownLatch cdl = new CountDownLatch(1);
    private String message;
    private volatile Throwable throwable;

    @Override
    public void onOpen(WsSession session) { <1>
        session.send("hello", true);
    }

    @Override
    public void onMessage(WsSession session, String text, boolean last) {   <2>
        this.message = text;
        session.close(WsCloseCodes.NORMAL_CLOSE, "End");
    }

    @Override
    public void onClose(WsSession session, int status, String reason) { <3>
        cdl.countDown();
    }

    @Override
    public void onError(WsSession session, Throwable t) {   <4>
        this.throwable = t;
        cdl.countDown();
    }
}
----
<1> Send "Hello", when a connection is opened;
<2> Save the message when received and close the connection;
<3> Close the connection;
<4> React on an error;

WebSocket `ClientSideListener` is also a helper class implementing `WsListener` and it is very straightforward:

.`ServerSideListener` helper class.
[source,java]
----
private static class ServerSideListener implements WsListener {
    boolean opened;
    boolean closed;
    String message;

    @Override
    public void onMessage(WsSession session, String text, boolean last) {   <1>
        message = text;
        session.send("ws", true);
    }

    @Override
    public void onClose(WsSession session, int status, String reason) {     <2>
        closed = true;
    }

    @Override
    public void onOpen(WsSession session) {     <3>
        opened = true;
    }

    void reset() {          <4>
        opened = false;
        closed = false;
        message = null;
    }
}
----
<1> Send "ws" on a received message;
<2> Called when the connection is called;
<3> Called on connection opened;
<4> Used to reset the state;

If only routing tests are required without real port opening, the testing class should be annotated with `@RoutingTest`. Instead of `WsClient` – `DirectWsClient` should be used.

=== Guides

Testing Guide <insert link here>

== Reference

* https://junit.org/junit5/docs/current/user-guide/[JUnit 5 User Guide]
