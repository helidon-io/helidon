///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2023 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Helidon Pico
:description: about Helidon Pico
:keywords: helidon, java, microservices, reactive, virtual threads





== Contents

- <<Overview, Overview>>
- <<Maven Coordinates, Maven Coordinates>>
- <<Usage, Usage>>
- <<API, API>>
- <<Configuration, Configuration>>
- <<Examples, Examples>>
- <<Additional Information, Additional Information>>

== Overview

Helidon Pico is an optional feature in Helidon that provides service registry, a lifecycle engine and extensibility for customized code generation. Foundationally, Pico provides a way to develop declarative code using standard Javax/Jakarta annotation types (not Helidon-specific). The Helidon Pico framework provides a mix of declarative and programmatic ways to build your application. 

Pico's minimalist, compile-time generated dependency injection (DI) framework and compile-time source code generation has a number of advantages, including:

* pre-runtime validation of the dependency injection model
* visibility into your application by providing "less magic" - understandability and debug-ability of your application
* deterministic behavior (instead of depending on reflection and classpath ordering, etc.)
* performance improvements since binding the model at compile-time is more efficient than computing it at runtime. 





== Maven Coordinates

To enable Pico add the following dependencies to your project's `pom.xml` (see Managing Dependencies).

.Pico dependencies
[source,java]

----
<dependency>
    <groupId>io.helidon.pico</groupId>
    <artifactId>helidon-pico-api</artifactId>
    <version>${helidon.version}</version>
</dependency>
<dependency>
    <groupId>io.helidon.pico</groupId>
    <artifactId>helidon-pico-types</artifactId>
    <version>${helidon.version}</version>
</dependency>
----

== Usage

These are the basic steps to help you get started with using Helidon Pico. 

NOTE: The Pico examples [link] provide detailed instructions for using Helidon Pico. 

*Step 1: Update your pom.xml file*

Put the following dependencies in your `pom.xml` or `gradle.build` file: 


.Builder dependencies
[source,java]
----
    
    <groupId>io.helidon.pico</groupId>
    <artifactId>helidon-pico-processor</artifactId>
    <version>${helidon.version}</version>
----

.Compile-time dependency:
[source,java]
----

  <dependency>
    <groupId>io.helidon.pico</groupId>
    <artifactId>helidon-pico-services</artifactId>
    <version>${helidon.version}</version>
  </dependency>
----


*Step 2: Write your application*

Write your application using w/ standard jakarta.inject.* and jakarta.annotation.* types. Again, see any of the examples for pointers as needed.

*Step 3: Build and run*

In a DI-based framework, the frameworks "owns" the creation of services in accordance with the Scope each service is declared as. You therefore need to get things started by creating demand for the initial service(s) instead of ever calling new directly in your application code. Generally speaking, there are two such ways to get things started at runtime:

    * If you know the class you want to create then look it up directly using the Services SPI. Here is a sample excerpt from the book example:

        Services services = PicoServices.realizedServices();
        // query
        ServiceProvider<MyService> serviceProvider = services.lookupFirst(MyService.class);
        // lazily activate
        MyService myLazyActivatedService = serviceProvider.get();

    * If there are a collection of services requiring activation at startup then we recommend annotating those service implementation types with `RunLevel(RunLevel.STARTUP)` and then use code below in `main()` to lazily activate those services. 
    

    
    * While Weight determines list order, the `RunLevel` annotation is used to rank the startup ordering, from the lowest value to the highest value, where `RunLevel.STARTUP == 0`. The developer is expected to activate these directly using code like the following (the get() lazily creates and activates the underlying service type):

      List<ServiceProvider<Object>> startupServices = services
              .lookup(DefaultServiceInfoCriteria.builder().runLevel(RunLevel.STARTUP).build());
      startupServices.stream().forEach(ServiceProvider::get);
    


NOTE: Whenever list-based injection is used in Pico, all services matching the injection criteria will be in the injected (and immutable) list. The list will always be in order according to the Weight annotation value, ranking from the highest weight to the lowest weight. If services are not weighted explicitly, then a default weight is assigned. If the weight is the same for two services, then the secondary ordering will be based on the FN class name of the service types. **If the ordering of the list of services is important, remember to use the Weight and/or RunLevel annotations to establish the priority / weighted ordering, and startup ordering.**






== API

The Pico framework aims to provide a minimalist API implementation. As a result, it might be surprising to learn how small the actual API is for Pico. If you are already familiar with `jakarta.inject` and `jakarta.annotation`, then you are ready to go. 



=== Maven Coordinates

.Pico API pom.xml
[source, java]
----
 <artifactId>helidon-pico-api</artifactId>
 <name>Helidon Pico API</name>
----


=== Types

The Pico API provides types that are generally useful at compile time to assign special meaning to the type. In this way it also helps with readability and intentions of the code itself.

.Pico types pom.xml
[source, java]
----
 <artifactId>helidon-pico-types</artifactId>
 <name>Helidon Pico Types</name>
----


 * {@link io.helidon.pico.api.Contract} - signifies that the type can be used for lookup in the service registry.
 * {@link io.helidon.pico.api.ExternalContracts} - same as Contract, but applied to the implementation class instead.
 * {@link io.helidon.pico.api.RunLevel} - ascribes meaning for when the service should start.






== Configuration

Configuration can be achieved through a Pico add-on that is based on Helidon's configuration subsystem, and adds support for something called _config-driven services_ using the `@ConfiguredBy` annotation. 

When applied to a target service interface, the `@ConfiguredBy` annotation will allow you to use a higher level aggregation for application configuration, and then allow the configuration to drive activation of services in the Pico Framework.

NOTE: You can use Pico configuration in combination with the Helidon configuration subsystem. 

There are a few additional caveats to understand about `ConfiguredBy` and its supporting infrastructure.

* `@ConfigBean Builder` is used to aggregate configuration attributes to this higher-level, application-centric configuration beans.

* The Pico Framework needs to be started with the supporting configdriven modules in order for configuration to drive service activation.




== Examples
For complete examples, see [link]. 

== Additional Information




