///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////
:adoc-dir: {guides-dir}

= Deploying to OKE
:description: Helidon Oracle Container Engine for Kubernetes (OKE) Guide
:keywords: helidon, guide, oracle, kubernetes

Pushing Helidon applications to the Oracle Registry Service and deploying to Oracle Container Engine for Kubernetes.

== What You Will Learn

You'll learn how to push the Docker image of your Helidon application to the Oracle Registry Service (OCIR) and deploy from the Registry Service to Oracle Container Engine for Kubernetes (OKE). 

== What You Need

|===
|About 10 minutes
| <<getting-started/01_prerequisites.adoc,Helidon Prerequisites>>
|Access to http://www.oracle.com/webfolder/technetwork/tutorials/obe/oci/oke-full/index.html[Oracle Container Engine for Kubernetes (OKE)]
|===

== Create Your Application Using The Creating Docker Images Guide

Follow the instructions on the link:05_Dockerfile.adoc[Creating Docker Images guide] to create a Docker image for your Helidon SE project. Once you have the image come back here.

== Pushing the Image to OCIR

You will need to log into your Oracle Cloud Infrastructure console and make sure you have a native OCI user. Currently federated users are not supported by OCIR. Your user will either need to be a part of the tenancy's Administrators group or another group with the `REPOSITORY_CREATE` permission. After confirming you have the proper permissions, generate an auth token for your user. Copy the token to a notepad as you will not be able to access it again.

Navigate to the Registry (OCIR) tab and choose the region to which you would like to push the image. Log into the Registry service Docker CLI with docker login `<region-code>.ocir.io`. When prompted, enter your username in the format `<tenancy_name>/<username>`. When prompted, enter the auth token copied earlier as the password.

The next step is to tag the quickstart image we are going to push to the registry:

`docker tag quickstart-se:latest <region-code>.ocir.io/<tenancy-name>/<repo-name>/<image-name>:<tag>``

Finally we push the image to the Registry:

`docker push <region-code>.ocir.io/<tenancy-name>/<repo-name>/<image-name>:<tag>``

`<region-code>`
`<region-code>` corresponds to the code for the Oracle Cloud Infrastructure Registry region you're using, as follows:

* enter `fra` as the region code for Frankfurt
* enter `iad` as the region code for Ashburn
* enter `lhr` as the region code for London
* enter `phx` as the region code for Phoenix

`ocir.io` is the Oracle Cloud Infrastructure Registry name.
`<tenancy-name>` is the name of the tenancy that owns the repository to which you want to push the image, for example `acme-dev`. Note that your user must have access to the tenancy.
`<repo-name>`, if specified, is the name of a repository to which you want to push the image ,for example, `project01`. Note that specifying a repository is optional. If you don't specify a repository name, the name of the image is used as the repository name in Oracle Cloud Infrastructure Registry.
`<image-name>` is the name you want to give the image in Oracle Cloud Infrastructure Registry, for example, helloworld.
`<tag>` is an image tag you want to give the image in Oracle Cloud Infrastructure Registry, for example, latest.

Within the Registry UI you will see the newly created repository. By default, the repository will be set to private. If you would like to continue with a private repository, you will have to add an image pull secret which allows Kubernetes to authenticate with a container registry to pull a private image. Let's first create a namespace for this project called `helidon` with `kubectl` create namespace helidon. We will deploy our application to this namespace. Next we will create the secret with:

`kubectl create secret docker-registry ocirsecret --docker-server=<region-code>.ocir.io --docker-username='<tenancy-name>/<oci-username>' --docker-password='<oci-auth-token>' --docker-email='<email-address> --namespace helidon`

Open up your `/target/app.yaml` file created with Maven and under spec next to containers in the deployment section add the following:

[source, yaml]
----
imagePullSecrets: 
        - name: ocirsecret
----
        
In the same file also under spec in the deployment section add the path listed on the Registry page to image under containers:

`<region-code.ocir.io>/<tenancy-name>/<quickstart-project-name>`

The final version will look something like this:

[source, yaml]
----
    spec:
      imagePullSecrets: 
      - name: ocirsecret
      containers:
      - name: helidon-se
        image: phx.ocir.io/oracle-cloudnative/example/quickstart-se:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
----

To make your life a little easier, you can skip past the secret creation step and simply make your registry public. You will still need to add the image location to your app.yaml file, but you will not need to create a secret or add `imagePullSecrets` to the yaml file.

=== Deploying to Kubernetes

Change to your quickstart-se directory and run `kubectl create -f target/app.yaml -n helidon` to deploy the application to the helidon namespace within your Kubernetes cluster.

Run `kubectl get svc -n helidon` to get the NodePort for your new pod. Run `kubectl get nodes` to get the IP address for your cluster nodes. Add the port number to the IP address of your node to get access to the deployed pod. If you browse to or cURL the same /greet endpoint you will see the same JSON output as you did when the application was deployed locally.

