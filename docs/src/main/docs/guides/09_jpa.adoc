///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Using JPA in Helidon MP
:description: Helidon JPA Guide
:keywords: helidon, guide, transaction, jpa, microprofile

This guide shows how to configure and use the
https://jcp.org/en/jsr/detail?id=338[Java Persistence API (JPA)] from
within a Helidon MP application.

== What You Need

|===
|About 30 minutes
|<<about/03_prerequisites.adoc,Helidon Prerequisites>>
|<<07_datasources.adoc,An understanding of named data source support in Helidon MP>>
|<<08_jta.adoc,An understanding of transaction support in Helidon MP>>
|An understanding of JPA itself
|===

== What You'll Do

By following this guide, you’ll enhance a bare-bones Helidon MP
application to use JPA, backed by
https://www.eclipse.org/eclipselink/#jpa[EclipseLink], to access an
in-memory https://www.h2database.com/html/main.html[H2
database]. You’ll see how to install the relevant dependencies and add
JPA-related code to your application.

== Use the Maven Archetype to Generate a Helidon MP Application

#Archetype instructions go here#

== Add the H2 Database Driver to the Runtime Classpath

Add the following dependency in your `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>1.4.199</version>
    <scope>runtime</scope>
</dependency>
----

In a production application, you may use a different database, so you
may add a different database driver dependency here instead.

== Add the Hikari Connection Pool Extension to the Runtime Classpath

Add the following dependency in your `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>io.helidon.integrations.cdi</groupId>
    <artifactId>helidon-integrations-cdi-datasource-hikaricp</artifactId>
    <scope>runtime</scope>
</dependency>
----

== Add the Provider-Independent Helidon JPA Integration to the Runtime Classpath

Add the following dependency in your `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>io.helidon.integrations.cdi</groupId>
    <artifactId>helidon-integrations-cdi-jpa</artifactId>
    <scope>runtime</scope>
</dependency>
----

== Add the EclipseLink JPA Integration to the Runtime Classpath

Add the following dependency in your `pom.xml`:

[source,xml]
----
<dependency>
    <groupId>io.helidon.integrations.cdi</groupId>
    <artifactId>helidon-integrations-cdi-eclipselink</artifactId>
    <scope>compile</scope> <!--1-->
</dependency>
----

<1> Note that the scope is `compile`.  We'll see why shortly.

== Add an `application.yaml` File With Database Connectivity Information

Add the following file under `src/main/resources`:

[source,yaml]
.`application.yaml`
----
javax:
    sql:
        DataSource:
            greetingDataSource:
                dataSourceClassName: org.h2.jdbcx.JdbcDataSource
                dataSource:
                    url: jdbc:h2:mem:greeting;INIT=RUNSCRIPT FROM 'classpath:greeting.ddl'
                    user: sa
                    password: ""
----

== Add DDL to Create the Relevant Database Tables

Add the following file under `src/main/resources`:

[source,sql]
.`greeting.ddl`
----
CREATE TABLE GREETING (
    SALUTATION VARCHAR(64) NOT NULL PRIMARY KEY,
    RESPONSE VARCHAR(64) NOT NULL
);

INSERT INTO GREETING (SALUTATION, RESPONSE) VALUES('Marco', 'Polo');
----

== Add a Java Class to Represent a Greeting JPA Entity

Add the following Java class under `src/main/java/com/example/entity`:

[source,java]
.`Greeting.java`
----
package com.example.entity;

import java.io.Serializable;

import javax.persistence.Access;
import javax.persistence.AccessType;
import javax.persistence.Basic;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Access(value = AccessType.FIELD) <1>
@Entity(name = "Greeting") <2>
@Table(name = "GREETING") <3>
public class Greeting implements Serializable { <4>

    @Column(
        insertable = true,
        name = "SALUTATION", <5>
        nullable = false,
        updatable = false
    )
    @Id <6>
    private String salutation;

    @Basic(optional = false) <7>
    @Column(
        insertable = true,
        name = "RESPONSE",
        nullable = false,
        updatable = true
    )
    private String response;

    @Deprecated
    protected Greeting() { <8>
        super();
    }

    public Greeting(String salutation, String response) { <9>
        super();
        this.salutation = Objects.requireNonNull(salutation);
        this.setResponse(response);
    }

    public String getSalutation() {
        return this.salutation;
    }

    public String getResponse() {
        return this.response;
    }

    public void setResponse(String response) {
        this.response = Objects.requireNonNull(response);
    }

    @Override
    public String toString() {
        return this.getSalutation() + " " + this.getResponse();
    }

}
----

<1> (Some of the annotations in this example, like this one, have
sensible defaults, but the example specifies them explicitly for
clarity.)  This
https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Access.html[`Access`
annotation] says that JPA will access this class' fields directly,
rather than via getter and setter methods.

<2> The
https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Entity.html[`Entity`
annotation] identifies this class as a JPA entity.  The
https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Entity.html#name--[`name`
element] value can be used in JPQL queries.

<3> The
https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Table.html[`Table`
annotation] identifies the database table to which this class will be
mapped.

<4> JPA entities should be `Serializable`.

<5> The
https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Column.html[`Column`
annotation] specifies what column in the database the annotated field
maps to.  The elements of the `Column` annotation further describe the
column.

<6> The
https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Id.html[`Id`
annotation] indicates this field will be mapped to the primary key of
the database table.

<7> The
https://javaee.github.io/javaee-spec/javadocs/javax/persistence/Basic.html[`Basic`
annotation] indicates this field will be mapped to an ordinary
("basic") column.

<8> All JPA entities need a zero-argument constructor, but it doesn't
have to be `public`.  This constructor satisfies this requirement.  It
is marked `Deprecated` and is non-`public` so that normal users have
to supply data for the `salutation` and `response` fields via the
other constructor.

<9> This is the constructor normal users will use.

