///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Health Check SE Guide
:description: Helidon health checks
:keywords: helidon, health-checks, health, check

This document describes how to both built-in and custom health checks with Helidon SE.

== What you need

[width=50%,role="flex, sm7"]
|===
|About 10 minutes
|Use the Quickstart SE guide to create a project <<guides/02_quickstart-se.adoc,Quickstart SE>>
|===

=== Using the built-in health-checks


A set of built-in health checks can be optionally enabled to report various
 health check statuses that are commonly used:

* deadlock detection
* available disk space
* available heap memory


[source,xml]
.Declare the following dependency in project's pom.xml file:
----
<dependency>
    <groupId>io.helidon.health</groupId>
    <artifactId>helidon-health-checks</artifactId>
</dependency>
----

.Modify Main.java to enable built-in health checks

[source,java]
----
HealthSupport health = HealthSupport.builder()
    .addLiveness(HealthChecks.healthChecks()) // <1>
    .build();

Routing.builder()
    .register(JsonSupport.create()) // <2>
    .register(health) // <3>
    .build();
----
<1> Add built-in health checks (requires the `helidon-health-checks`
 dependency).
<2> Register the `JSON-P` support in the WebServer routing.
<3> Register the created health support with web server routing (adds the
`/health` endpoint).

.Restart the application and verify the health endpoint:

[source,bash]
----
curl -X GET http://localhost:8080/health
----

[source,json]
.JSON response.
----
{
    "outcome": "UP",
    "checks": [
        {
            "name": "deadlock",
            "state": "UP"
        },
        {
            "name": "diskSpace",
            "state": "UP",
            "data": {
                "free": "211.00 GB",
                "freeBytes": 226563444736,
                "percentFree": "45.31%",
                "total": "465.72 GB",
                "totalBytes": 500068036608
            }
        },
        {
            "name": "heapMemory",
            "state": "UP",
            "data": {
                "free": "215.15 MB",
                "freeBytes": 225600496,
                "max": "3.56 GB",
                "maxBytes": 3817865216,
                "percentFree": "99.17%",
                "total": "245.50 MB",
                "totalBytes": 257425408
            }
        }
    ]
}
----

=== Custom health-checks

You can easily create any number of application specific custom health checks and integrate
them with Helidon using the `HealthSupport` class, which is a  WebServer service that contains
a collection of registered `HealthCheck` instances. When queried, it invokes the registered
health check and returns a response with a status code representing the overall
state of the application.

[source,xml]
.Declare the following dependency in project's pom.xml file:
----
<dependency>
    <groupId>io.helidon.health</groupId>
    <artifactId>helidon-health</artifactId>
</dependency>
----

[source,java]
.Register a custom health check in Main.java
----
HealthSupport health = HealthSupport.builder()
  .addLiveness(() -> HealthCheckResponse.named("exampleHealthCheck")
      .up()
      .withData("time", System.currentTimeMillis())
      .build()) // <1>
  .build();

----
<1> Add a custom health check. This example returns `UP` and current time.

.Restart the application and verify the custom health endpoint:

[source,bash]
----
curl -X GET http://localhost:8080/health
----

[source,json]
.JSON response:
----
{
    "outcome": "UP",
    "checks": [
        {
            "name": "exampleHealthCheck",
            "state": "UP",
            "data": {
                "time": 1546958376613
            }
        }
    ]
}
----

=== Combine built-in and custom health-checks

You can combine built-in and custom health checks using the same HealthSupport builder.

[source,java]
.Register a custom health check in Main.java
----
HealthSupport health = HealthSupport.builder()
   .addLiveness(HealthChecks.healthChecks()) // <1>
  .addLiveness(() -> HealthCheckResponse.named("exampleHealthCheck")
      .up()
      .withData("time", System.currentTimeMillis())
      .build())
  .build();

----
<1> Add the built-in health checks to HealthSupport builder

.Restart the application and verify the health endpoint.  You will see both the built-in and custom health check data:

[source,bash]
----
curl -X GET http://localhost:8080/health
----

[source,json]
.JSON response:
----
{
  "outcome": "UP",
  "status": "UP",
  "checks": [
    {
      "name": "deadlock",
      "state": "UP",
      "status": "UP"
    },
    {
      "name": "diskSpace",
      "state": "UP",
      "status": "UP",
      "data": {
        "free": "326.30 GB",
        "freeBytes": 350358409216,
        "percentFree": "70.08%",
        "total": "465.63 GB",
        "totalBytes": 499963174912
      }
    },
    {
      "name": "exampleHealthCheck",
      "state": "UP",
      "status": "UP",
      "data": {
        "time": 1566231033702
      }
    },
    {
      "name": "heapMemory",
      "state": "UP",
      "status": "UP",
      "data": {
        "free": "245.18 MB",
        "freeBytes": 257092376,
        "max": "4.00 GB",
        "maxBytes": 4294967296,
        "percentFree": "99.74%",
        "total": "256.00 MB",
        "totalBytes": 268435456
      }
    }
  ]
}
----
