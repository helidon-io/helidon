///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2018, 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Helidon MP Tutorial
:description: Helidon MP Tutorial
:keywords: helidon

This guide describes how to build an Helidon MP application from scratch 
 including JSON REST endpoints, metrics, health check, and configuration.

== What you need

[width=50%,role="flex, sm7"]
|===
|About 15 minutes
|<<about/03_prerequisites.adoc,Helidon Prerequisites>>
|===

== Create The Project

In this guide, we will create the application from scratch, without
 using the Maven archetypes as a quickstart. 
 
Create a new empty directory for the project (for example, `helidon-mp-from-scratch`).  Change into this directory.

Create a new Maven POM file (called `pom.xml`) and add the following
 content: 
 
[source,xml,subs="attributes+"]
.Initial Maven POM file
----
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>

    <groupId>io.helidon.examples</groupId>
    <artifactId>helidon-mp-from-scratch</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>${project.artifactId}</name>

    <properties>
        <helidon.version>1.2.0</helidon.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.helidon</groupId>
                <artifactId>helidon-bom</artifactId>
                <version>${helidon.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>io.helidon.microprofile.bundles</groupId>
            <artifactId>helidon-microprofile-2.2</artifactId>
        </dependency>
    </dependencies>

</project>
----

This POM files contains just the basics that we need to get started.  It
 established the Maven coordinates for our new project and it brings in 
 the Helidon BOM POM (in the `dependencyManagement` section) and adds a 
 dependecny for the MicroProfile 2.2 bundle which will allow us to use
 all of the MicroProfile 2.2 features in out application.

At this point, we can build our application successfully with Maven:

[source,bash]
----
mvn clean package
----

This will create a JAR file in the `target` directory.

TIP: You can ignore the warning message `JAR will be empty - 
 no content was marked for inclusion!` for now becuase we have not added 
 any actual content to our application yet.

== Create our MicroProfile Application class

Now we are ready to actually start building our application logic.
 The first step is to add the application class. Create a directory
 for your source code, and then create directories for our package 
 hierarchy:

[source,bash]
.Create directories for source code
----
mkdir -p src/main/java/io/helidon/examples
----

Our application will be a simple REST service that will return a 
 greeting to the caller.  To get started we need to create a
 MicroProfile Application class, a resource and a Main class to
 start up the application.

Create a new Java class inside that directory called `GreetApplication.java`
 and add the following content:

[source,java]
.Initial application class
----
package io.helidon.examples;

import io.helidon.common.CollectionsHelper;

import javax.enterprise.context.ApplicationScoped;
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;
import java.util.Set;

@ApplicationScoped
@ApplicationPath("/")
public class GreetApplication extends Application {

    @Override
    public Set<Class<?>> getClasses() {
        return CollectionsHelper.setOf(GreetResource.class);
    }
}
----

write me

[source,java]
.Initial resource class
----
package io.helidon.examples;

import javax.enterprise.context.RequestScoped;
import javax.json.Json;
import javax.json.JsonBuilderFactory;
import javax.json.JsonObject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import java.util.Collections;

@Path("/greet")
@RequestScoped
public class GreetResource {

    private static final JsonBuilderFactory JSON = Json.createBuilderFactory(Collections.emptyMap());

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public JsonObject getDefaultMessage() {
        return JSON.createObjectBuilder()
                .add("message", "Hello World")
                .build();
    }

}
----

write me

[source,java]
.Initial Main class
----
package io.helidon.examples;

import io.helidon.microprofile.server.Server;

import java.io.IOException;

public final class Main {

    private Main() { }

    public static void main(final String[] args) throws IOException {
        Server server = startServer();
        System.out.println("http://localhost:" + server.port() + "/greet");
    }

    static Server startServer() {
        return Server.create().start();
    }
    
}
----

write me




[source,bash]
.Build the Application
----
mvn package
----

The project builds an application jar for the example and saves all runtime 
dependencies in the `target/libs` directory. This means you can easily start the
 application by running the application jar file:

[source,bash]
.Run the application
----
java -jar target/helidon-quickstart-se.jar
----

The example is a very simple "Hello World" greeting service. It supports GET
 requests for generating a greeting message, and a PUT request for changing the
 greeting itself. The response is encoded using JSON.
For example:

[source,bash]
.Try the Application
----
curl -X GET http://localhost:8080/greet
{"message":"Hello World!"}

curl -X GET http://localhost:8080/greet/Joe
{"message":"Hello Joe!"}

curl -X PUT -H "Content-Type: application/json" -d '{"greeting" : "Hola"}' http://localhost:8080/greet/greeting

curl -X GET http://localhost:8080/greet/Jose
{"message":"Hola Jose!"}
----

== Health and Metrics

Helidon provides built-in support for health and metrics endpoints.

[source,bash]
.Health
----
curl -s -X GET http://localhost:8080/health
----

[source,bash]
.Metrics in Prometheus Format
----
curl -s -X GET http://localhost:8080/metrics
----

[source,bash]
.Metrics in JSON Format
----
curl -H 'Accept: application/json' -X GET http://localhost:8080/metrics
----

== Build a Docker Image

The project also contains a Dockerfile so that you can easily build and run a
 Docker image. To build the Docker image, you need to have Docker installed and
 running on your system.

[source,bash]
.Docker build
----
docker build -t helidon-quickstart-se .
----

[source,bash]
.Run Docker Image
----
docker run --rm -p 8080:8080 helidon-quickstart-se:latest
----

Then you can try the application as you did before.

== Deploy the application to Kubernetes

If you don't have access to a Kubernetes cluster, you can
<<getting-started/05_kubernetes.adoc,install one on your desktop>>.
Then deploy the example:

[source,bash]
.Verify connectivity to cluster
----
kubectl cluster-info
kubectl get nodes
----

[source,bash]
.Deploy the application to Kubernetes
----
kubectl create -f app.yaml
kubectl get pods                    # Wait for quickstart pod to be RUNNING
----

The step above created a service that is exposed into any node port. Lookup
 the service to find the port.

[source,bash]
.Lookup the service
----
kubectl get service helidon-quickstart-se
----

Note the PORTs. You can now exercise the application as you did before but use
 the second port number (the NodePort) instead of 8080. For example:

[source,bash]
curl -X GET http://localhost:31431/greet

After you're done, cleanup.

[source,bash]
.Remove the application from Kubernetes
----
kubectl delete -f app.yaml
----
