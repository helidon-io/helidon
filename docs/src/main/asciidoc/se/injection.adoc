///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2025 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Overview

:description: Dependency Injection in Helidon SE
:keywords: helidon, se, injection
:h1Prefix: SE
:feature-name: Injection
:rootdir: {docdir}/..

include::{rootdir}/includes/se.adoc[]

== Contents

- <<Overview, Overview>>
- <<Maven Coordinates, Maven Coordinates>>
- <<Usage, Usage>>
- <<Basic terms, Basic terms>>
- <<How are services defined, How are services defined?>>
- <<Injection points, Injection points>>
- <<Scopes, Scopes>>
- <<Build time, Build time>>
- <<Basic injection example, Basic injection example>>
- <<Service Lifecycle, Service Lifecycle>>
- <<Qualifiers, Qualifiers>>
- <<Factories, Factories>>
- <<Interceptors, Interceptors>>
- <<Events, Events>>
- <<Programmatic Lookup, Programmatic Lookup>>
- <<Startup, Startup>>

== Overview

Injection is the basic building stone for inversion of control. Dependency injection provides a mechanism to get
an instance of a service at runtime, from the service registry, rather than constructing service instances through
a constructor or a factory method.

include::{rootdir}/includes/dependencies.adoc[]

[source,xml]
----
<dependency>
    <groupId>io.helidon.service</groupId>
    <artifactId>helidon-service-registry</artifactId>
</dependency>
----

== Usage
To start using Helidon Inject, you need to create both:

- A service that will be injected.
- An injection point, where the service instance will be injected.

Let's begin by explaining some basic terms.

== Basic terms

=== Declarative style of programming
In a declarative approach, you use annotations on classes, constructors, and constructor arguments to express your intent.

For example, instead of manually managing dependencies,
you declare that a class should be injectable using annotations like `@Service.Singleton`
(More about that later).

=== Service registry
A service registry is a tool that enables declarative programming by supporting inversion of control (IoC).

It manages the lifecycle of services, handles dependency injection,
and ensures that the correct instances are provided where needed and without requiring manual instantiation.

=== Inversion of control
Instead of manually creating an instance of a certain type, you can delegate its creation to the service registry.

This allows the registry to handle the entire instantiation process and provide the instance when needed,
ensuring proper lifecycle management and dependency resolution.

=== Contract
A contract is a type that defines what the service registry should provide.
It represents an API that will be used.

For simplicity, a contract can be thought of as an interface,
but it can also be an abstract class or even a concrete class.

[source,java]
.Contract example
----
interface GreetingContract {

    String greet(String name);

}
----

=== Service
This can be either a concrete class, which implements the contract
(or is contract itself if it was a concrete class),
or it can be a factory/producer (more about <<Factories, Factories>>),
which creates a new instances to be registered into the service registry.

[source,java]
.Service example
----
@Service.Singleton
class MyGreetingService implements GreetingContract {

    public String greet(String name) {
        return "Hello %s!".formatted(name);
    }

}
----

=== Contract vs. service
Contract and service can be the same thing, but also separate entities.

== How are services defined
Services are defined by:

1. Java classes annotated with one of the `Service.Scope` annotations (see <<Scopes, Scopes>>)
2. Any class with `@Service.Inject` annotation even when it doesn’t have a scope annotation. In such a case, the scope of the service will be set as `@Service.PerLookup`.

Now, let's talk about an injection points.

== Injection points
In Helidon, dependency injection can be done into the injection point in the following ways:

1. Through a constructor annotated with `@Service.Inject` - each parameter is considered an injection point; this is the recommended way of injecting dependencies (as it can be unit tested easily, and fields can be declared private final)
2. Through field(s) annotated with `@Service.Inject` - each field is considered an injection point; this is not recommended, as the fields must be accessible (at least package local), and can’t be declared as final

Injected services are picked by the highest weight and implementing the requested contract.
Only services can have Injection points.

=== Injected dependency formats

Dependencies can be injected in different formats, depending on the required behavior:

- `Contract` - Retrieves an instance of another service.
- `Optional<Contract>` - Retrieves an instance, but if the service is unavailable, an empty optional is provided.
- `List<Contract>` - Retrieves all available instances of a given service.
- `Supplier<Contract>`, `Supplier<Optional<Contract>>`, `Supplier<List<Contract>>` - Similar to the above, but the value is only resolved when get() is called, allowing lazy evaluation for more control.

The same behavior can be achieved programmatically using the `io.helidon.service.registry.ServiceRegistry` instance.
To obtain a `ServiceRegistry`, you can retrieve it from a `ServiceRegistryManager`,
allowing manual lookup and management of services. See <<Programmatic Lookup, Programmatic Lookup>> chapter.

== Scopes
Helidon Inject provides three built-in scopes:

- `@Service.Singleton` – A single instance exists in the service registry for the application's lifetime.
- `@Service.PerLookup` – A new instance is created each time a lookup occurs (including when injected into an injection point).
- `@Service.PerRequest` – A single instance per request exists in the service registry. The definition of a "request" is not enforced by the injection framework but aligns with concepts like an HTTP request-response cycle or message consumption in a messaging system.

== Build time
To ensure everything functions correctly,
you need to add the following annotation processors to your application's compilation process.

These processors generate the necessary metadata and wiring for dependency injection and service registration in Helidon Inject.

For Maven:
[source,xml]
.Example annotation processor configuration in Maven
----
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
                <annotationProcessorPaths>
                    <path>
                        <groupId>io.helidon.codegen</groupId>
                        <artifactId>helidon-codegen-apt</artifactId>
                        <version>${helidon.version}</version>
                    </path>
                    <path>
                        <groupId>io.helidon.service</groupId>
                        <artifactId>helidon-service-codegen</artifactId>
                        <version>${helidon.version}</version>
                    </path>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
    </plugins>
</build>
----

=== Why are these annotation processors needed?
Annotation processor `helidon-service-codegen` generates a service descriptor (`ServiceProvider__ServiceDescriptor`) for each discovered service.
This descriptor is discovered at runtime and is used to instantiate the service without relying on reflection, improving performance and reducing overhead during service creation.

== Basic injection example

To demonstrate how Helidon Inject works, let's create a simple working example where one service is injected into another.

[source,java]
.Creating simple Greeter service.
----
include::{sourcedir}/se/inject/BasicExample.java[tag=snippet_1, indent=0]
----

Once the Greeter service is created, an injection point for this service is now required.
Let's create another service that injects the Greeter service as its constructor parameter.

[source,java]
.Create simple injection point
----
include::{sourcedir}/se/inject/BasicExample.java[tag=snippet_2, indent=0]
----

Now it just needs to be tested. The easiest way is to make a main method. The following piece of code
initializes Service registry. After that we search for our `GreetingInjectionService` and execute it
to print out `Hello David!`. To find out more about this manual approach, please take a look into the <<Programmatic Lookup, Programmatic Lookup>> chapter.
[source,java]
.Lookup our created service and execute it manually
----
include::{sourcedir}/se/inject/BasicExample.java[tag=snippet_3, indent=0]
----

If everything went as expected, no problems occurred and Service registry gave us fully initialized
and ready to use service.

== Service Lifecycle

The service registry manages the lifecycle of services. To ensure a method is invoked at a specific lifecycle phase, you can use the following annotations:

* `@Service.PostConstruct` – Invokes the annotated method after the instance has been created and fully injected.
* `@Service.PreDestroy` – Invokes the annotated method when the service is no longer in use by the registry. (Such as if the intended scope ends)
** `@Service.PerLookup` – PreDestroy annotated method is not invoked, since it is not managed by the service registry after the injection.
** *Other scopes* – The pre-destroy method is invoked when the scope is deactivated (e.g. for singletons this happens during registry or JVM shutdown).

== Qualifiers
In dependency injection, a qualifier is a way to tell the framework which dependency to use when there are multiple options available.

Annotations are considered qualifier if they’re "meta-annotated" with `@Service.Qualifier`.

Helidon Inject comes with one qualifier provided out-of-the-box - the `@Service.Named` (and `@Service.NamedByType` which does the same thing, but uses class instead of a `String` name)

=== Named service injection

Services can be assigned names, allowing them to be specified by name during injection.
This ensures that the correct service is injected. To achieve this, we use the @Service.Named annotation.

[source,java]
.Create named services
----
include::{sourcedir}/se/inject/QualifierExample.java[tag=snippet_1, indent=0]
----

These named services can now be injected at specific injection points using their assigned names
[source,java]
.Create BlueCircle with Blue color injected
----
include::{sourcedir}/se/inject/QualifierExample.java[tag=snippet_2, indent=0]
----
[source,java]
.Create GreenCircle with Green color injected
----
include::{sourcedir}/se/inject/QualifierExample.java[tag=snippet_3, indent=0]
----

=== Named by the type
Alternatively, instead of using string-based names for services, a specific class can be used to "name" them. For this purpose, we use the @Service.NamedByType annotation.

[source,java]
.Named by type usage example
----
include::{sourcedir}/se/inject/QualifierExample.java[tag=snippet_4, indent=0]
----

The way it is used on the injection point, it is the same as it was in case of the `@Service.Named`.

[source,java]
.Named by type injection point
----
include::{sourcedir}/se/inject/QualifierExample.java[tag=snippet_5, indent=0]
----

=== Custom qualifiers
To make custom qualifiers, it is necessary to "meta-annotated" it with `@Service.Qualifier`.

[source,java]
.Create Blue and Green custom qualifiers
----
include::{sourcedir}/se/inject/Qualifier2Example.java[tag=snippet_1, indent=0]
----
The `@Blue` and `@Green` annotations serve as our new qualifiers.
It can now be used to qualify services in the same way as `@Service.Named`.

[source,java]
.Custom qualifier Blue and Green usage
----
include::{sourcedir}/se/inject/Qualifier2Example.java[tag=snippet_2, indent=0]
----

Once the services are created and qualified, they can be injected in the same way as before using the following approach

[source,java]
.Custom qualifier usage on injection point
----
include::{sourcedir}/se/inject/Qualifier2Example.java[tag=snippet_3, indent=0]
----

== Factories
Let's consider we have a contract named `MyContract`.

The simple case is that we have a class that implements the contract, and that is a service, such as:

[source,java]
----
@Service.Singleton
class MyImpl implements MyContract {
}
----

This means that the service instance itself serves as the implementation of the contract. When this service is injected into a dependency injection point, we receive an instance of MyImpl.

However, this approach only works if the contract is an interface and we’re implementing it fully. In some cases, this may not be enough, such as when:

- The instance needs to be provided by an external source.
- The contract is not an interface.
- The instance may not always be created (e.g., it is optional).

These challenges can be addressed by implementing one of the factory interfaces supported by the Helidon Service Registry:

- `java.util.function.Supplier`
- `io.helidon.service.registry.Service.ServicesFactory`
- `io.helidon.service.registry.Service.InjectionPointFactory`
- `io.helidon.service.registry.Service.QualifiedFactory`

=== java.util.function.Supplier
A factory that supplies a single instance (it can also return `Supplier<Optional<MyContract>>`)
[source,java]
.Supplier factory
----
include::{sourcedir}/se/inject/FactoryExample.java[tag=snippet_1, indent=0]
----

=== io.helidon.service.registry.Service.ServicesFactory
A factory that creates zero or more implementations of a given contract.

[source,java]
.ServicesFactory example
----
include::{sourcedir}/se/inject/FactoryExample.java[tag=snippet_2, indent=0]
----

If the created services need to be qualified, any relevant qualifier information must also be included in the factory annotations.

Note: If one doesn’t want to list all the name qualifiers provided by this factory, it is possible use `*` to cover all the possible names.

[source,java]
----
include::{sourcedir}/se/inject/FactoryExample.java[tag=snippet_3, indent=0]
----

=== io.helidon.service.registry.Service.QualifiedFactory
Qualified factory is strictly bound to a specific qualifier type.
It will get executed only for injection points,
which are annotated with this selected qualifier and are intended for a selected contract.
It will be ignored for any other injection points.

It receives a Lookup object as a parameter, which contains all necessary information about the injection point.
This allows the factory to create instances dynamically based on the injection point information.

[source,java]
----
include::{sourcedir}/se/inject/FactoryExample.java[tag=snippet_4, indent=0]
----

=== io.helidon.service.registry.Service.InjectionPointFactory
This type of factory is very similar to `QualifiedFactory`,
but with one key difference—it is executed for each injection point and is not bound to a specific qualifier/s (unless specified).

It receives a Lookup object as a parameter, which contains all necessary information about the injection point.
This allows the factory to create instances dynamically based on the injection point information.

[source,java]
----
include::{sourcedir}/se/inject/FactoryExample.java[tag=snippet_5, indent=0]
----

It is possible to restrict this factory to specific qualifiers by specifying them at the class level of the factory.

This ensures that the factory is executed only for injection points that match the intended contract and qualifier.

[source,java]
----
include::{sourcedir}/se/inject/FactoryExample.java[tag=snippet_6, indent=0]
----

== Interceptors
Interception allows intercepting calls to constructors or methods, and even fields when used as injection points.

By default, interception is enabled only for elements annotated with `Interception.Intercepted`. However, annotation processor configurations can enable interception for any annotation or disable it entirely.

Interception wraps around the invocation, enabling it to:

* Execute logic before the actual invocation
* Modify invocation parameters
* Execute logic after the actual invocation
* Modify the response
* Handle exceptions

=== Intercepted annotation
The `@Interception.Intercepted` annotation is a marker used to indicate that an annotation should trigger interception.

[source,java]
.Custom annotation for interception
----
include::{sourcedir}/se/inject/InterceptorExample.java[tag=snippet_1, indent=0]
----

=== Interceptor interface
The `io.helidon.service.registry.Interception.Interceptor` interface defines an interceptor service that intercepts methods/constructors/fields annotated with the configured marker annotation. This supported marker annotation is specified using `@Service.NamedByType`. To properly handle the interception chain, the interceptor must always invoke the `proceed` method.

[source,java]
.Sample Interceptor interface implementation
----
include::{sourcedir}/se/inject/InterceptorExample.java[tag=snippet_2, indent=0]
----

<1> Binds this Interceptor to process annotated with `@Traced`
<2> Passing interceptor processing to another interceptor in the chain

=== Delegate annotation
The `@Interception.Delegate` annotation enables interception for classes
that aren’t created through the service registry
but are instead produced by a factory (More about factories can be found here -
<<Factories, Factory chapter>>).
To enable interception, this annotation must be present on the class that the factory produces.
While it is not required on interfaces, it will still function correctly if applied there.

Let's make the same `@Traced` annotation and Interceptor as in the previous examples

[source,java]
.Custom annotation and interceptor
----
include::{sourcedir}/se/inject/InterceptorDelegateExample.java[tag=snippet_1, indent=0]
----

Now, let's create the factory of the service instance.

[source,java]
.Instance producer
----
include::{sourcedir}/se/inject/InterceptorDelegateExample.java[tag=snippet_2, indent=0]
----

Method calls on an instance created this way can’t be intercepted. To enable interception in such cases, we use the `@Interception.Delegate` annotation. However, keep in mind that usage of this annotation doesn’t add the ability to intercept constructor calls.

If you need to enable interception for classes using delegation, you should:

- The class must have accessible no-arg constructor (at least package local)
- The constructor should have no side effects, as the instance will act only as a wrapper for the delegate
- All invoked methods must be accessible (at least package local)

[source,java]
.Delegate used on the class
----
include::{sourcedir}/se/inject/InterceptorDelegateExample.java[tag=snippet_3, indent=0]
----

// === ExternalDelegate annotation
// TODO Uncomment this, once this issue is fixed https://github.com/helidon-io/helidon/issues/9726
// The `@Interception.ExternalDelegate` annotation functions similarly to `@Interception.Delegate`. However, the key difference is that `@Interception.ExternalDelegate` is designed for classes that you don’t control. This means it allows you to apply the interception mechanism even to third-party classes.
//
// [source,java]
// .ExternalDelegate used for external class
// ----
// include::{sourcedir}/se/inject/InterceptorDelegateExample.java[tag=snippet_4, indent=0]
// ----

== Events
Events enable in-application communication between services by providing a mechanism to emit events and register consumers to handle them.

A single event can be delivered to zero or more consumers.

Key Terminology:

- *Event Object* – Any object that is sent as an event.
- *Event Emitter* – A service responsible for emitting events into the event system.
- *Event Producer* – A service that triggers an event by calling an emitter.
- *Event Observer* – A service that listens for events, with a method annotated using `io.helidon.service.registry.Event.Observer`.
- *Qualified Event* – An event emitted with a qualifier, using an annotation marked with `Service.Qualifier`.

=== Event Object
To begin emitting events, the first step is to define the event type itself.

[source,java]
.Create a desired event type
----
include::{sourcedir}/se/inject/EventsExample.java[tag=snippet_1, indent=0]
----

=== Event Emitter
Event emitters are code generated by Helidon. So we don't make them ourselves.

=== Event Producer
An event producer is a service which triggers the event by using the event emitter.

To emit an event, inject the desired event emitter, construct the corresponding event object, and call the emit method on the emitter instance.

[source,java]
.Event producer example
----
include::{sourcedir}/se/inject/EventsExample.java[tag=snippet_2, indent=0]
----
The method returns only after all event observers have been notified. If any observer throws an exception, an `EventDispatchException` is thrown, with all caught exceptions added as suppressed. This ensures that all observers are invoked, even if an exception occurs.

=== Event Observer
An event observer is a service which processes fired event.

To create an event observer:

- create an observer method, with a single parameter of the event type you want to observe
- annotate the method with `@Event.Observer`

[source,java]
.Event observer example
----
include::{sourcedir}/se/inject/EventsExample.java[tag=snippet_3, indent=0]
----

== Qualified Events

A Qualified Event is only delivered to Event Observers that use the same qualifier.

=== Qualified Event Producer

A qualified event can be produced with two options:

1. The injection point of `Event.Emitter` (the constructor parameter, or field) is annotated with a qualifier annotation
2. The `Event.Emitter.emit(..)` method is called with explicit qualifier(s), note that if combined, the qualifier specified by the injection point will always be present!

In this example below, we create event producer, which fires event only to observers qualified with name "id".
[source,java]
.Qualified event producer
----
include::{sourcedir}/se/inject/EventsExample.java[tag=snippet_6, indent=0]
----

=== Qualified Event Observers

To consume a qualified event, observer method must be annotated with the correct qualifier(s).

[source,java]
.Qualified event observer
----
include::{sourcedir}/se/inject/EventsExample.java[tag=snippet_7, indent=0]
----

== Asynchronous Events
Events can be emitted asynchronously, and event observers can also operate asynchronously.

An executor service for handling asynchronous events can be registered in the service registry by providing a service that implements the `java.util.concurrent.ExecutorService` contract and is named `io.helidon.service.registry.EventManager`.

If no custom executor service is provided, the system defaults to a per-task executor using Virtual Threads, with thread names prefixed as `inject-event-manager-`.

=== Asynchronous Event Producer
All asynchronous event producers must use the `Event.Emitter.emitAsync(..)` method instead of the synchronous `Event.Emitter.emit(..)`.

The `emitAsync` method returns a `CompletionStage<MyEvent>` instance. When executed, it completes once all event observers have been submitted to the executor service. However, there is no guarantee that any event has been delivered—it may have been sent to anywhere from 0 to n observers (where n represents the number of synchronous observers).

[source,java]
.Asynchronous Event Producer Example
----
include::{sourcedir}/se/inject/EventsExample.java[tag=snippet_4, indent=0]
----

=== Asynchronous Observer
Asynchronous observer methods are invoked from separate threads (through the executor service mentioned above), and their results are ignored by the Event Emitter; if there is an exception thrown from the observer method, it is logged with `WARNING` log level into logger named `io.helidon.service.registry.EventManager`.

To declare an asynchronous observer use annotation `Event.AsyncObserver` instead of `Event.Observer`.

[source,java]
.Asynchronous Event Observer Example
----
include::{sourcedir}/se/inject/EventsExample.java[tag=snippet_5, indent=0]
----

== Programmatic Lookup

There are two primary ways to access services from the service registry:

- *Dependency Injection* – Services are injected automatically at defined injection points.
- *Programmatic Lookup* – Services are retrieved manually by accessing the service registry directly.

If you want to use programmatic lookup, there are two main ways to access a `ServiceRegistry` instance:

- Create a new ServiceRegistry instance and search for the desired service.
- Inject the existing ServiceRegistry instance currently used by Helidon and retrieve services from it.

To create a registry instance:

[source,java]
----
include::{sourcedir}/se/inject/ServiceRegistryExample.java[tag=snippet_1, indent=0]
----

Note that all instances are created lazily, meaning the service registry does nothing by default.
If a service performs any actions during construction or post-construction,
you must first retrieve an instance from the registry to trigger its initialization.

Special registry operations:

- `List<ServiceInfo> lookupServices(Lookup lookup)` - get all service descriptors that match the lookup
- `Optional<T> get(ServiceInfo)` - get an instance for the provided service descriptor

The common registry operations are grouped by method name. Acceptable parameters are described below.

Registry methods:

- `T get(...)` - immediately get an instance of a contract from the registry; throws if implementation not available
- `Optional<T> first(...)` - immediately get an instance of a contract from the registry; there may not be an implementation
available
- `List<T> all(...)` - immediately get all instances of a contract from the registry; result may be empty
- `Supplier<T> supply(...)` - get a supplier of an instance; the service may be instantiated only when `get` is called
- `Supplier<Optional<T>> supplyFirst(...)` - get a supplier of an optional instance
- `Supplier<List<T>> supplyAll(...)` - get a supplier of all instances

Lookup parameter options:

- `Class<?>` - the contract we are looking for
- `TypeName` - the same, but using Helidon abstraction of type names (may have type arguments)
- `Lookup` - a full search criteria for a registry lookup

== Startup

Helidon provides a Maven plugin (`io.helidon.service:helidon-service-maven-plugin`, goal `create-application`) to generate
build time bindings, that can be used to start the service registry without any classpath discovery and reflection.
Default name is `ApplicationBinding` (customizable)

Methods that accept the bindings are on `io.helidon.service.registry.ServiceRegistryManager`:

- `start(Binding)` - starts the service registry with the generated binding, initializing all singleton and per-lookup services annotated with a `@RunLevel` annotation (i.e. `start(ApplicationBinding.create())`)
- `start(Binding, ServiceRegistryConfig)` - same as above, allows for customization of configuration, if used, do not forget to set discovery to `false` to prevent automated discovery from the classpath

All options to start a Helidon application that uses service registry:

- A custom Main method using `ServiceRegistryManager.start(...)` methods, or `ServiceRegistryManager.create(...)` methods
- A generated `ApplicationMain` - optional feature of the Maven plugin, requires property `generateMain` to be set to `true`
- The Helidon startup class `io.helidon.Main`, which will start the registry manager and initialize all `RunLevel` services, though it uses service discover (which in turn must use reflection to get service descriptor instances)

