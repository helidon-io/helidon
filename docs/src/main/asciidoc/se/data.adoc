///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2020, 2025 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= About Helidon Data Repository
:description: Helidon Data Repository
:keywords: helidon, se, database, data, repository
:feature-name: Data Repository
:rootdir: {docdir}/..

include::{rootdir}/includes/se.adoc[]

== Contents

-  <<Overview, Overview>>
-  <<Maven Coordinates, Maven Coordinates>>
-  <<Annotation Processor, Annotation Processor>>
-  <<Usage, Usage>>
-  <<Helidon Config, Helidon Config>>
-  <<SE Application, SE Application>>
-  <<Repository Interface, Repository Interface>>
-  <<Pagination, Pagination>>
-  <<Dynamic Sorting, Dynamic Sorting>>
-  <<Persistence Session Access, Persistence Session Access>>

== Overview

The Helidon SE Data Repository provides a unified API for working with database queries.
Data repository queries are an abstraction on top of Objectâ€“Relational Mapping (ORM). This
allows compile time translation of interfaces with query definitions into implementing classes.

Supported ORM is Jakarta Persistence 3.1 and EclipseLink or Hibernate providers.

include::{rootdir}/includes/dependencies.adoc[]

[source,xml]
----
include::{sourcedir}/../../../../../../pom.xml[tag=data_dependencies, indent=0]
----

Jakarta Persistence provider (EclipseLink) and Database (MySQL) JDBC driver runtime dependencies:

[source,xml]
----
include::{sourcedir}/../../../../../../pom.xml[tag=data_eclipselink_dependencies, indent=0]
----

== Annotation Processor

Both ORM entity model and data repository interfaces require specific annotation processor configuration:

[source,xml]
----
include::{sourcedir}/../../../../../../pom.xml[tag=data_annotationProcessorPaths, indent=0]
----

== Usage

The Data Repository provides API and tools to implement database queries using interface method prototypes.
There are two ways how such a query may be defined:

* using method annotated with `@Data.Query`

[source,java]
----
include::{sourcedir}/se/data/PetRepository.java[tag=listPets_method, indent=0]
----

* using method name as query definition

[source,java]
----
include::{sourcedir}/se/data/PetRepository.java[tag=findByName_method, indent=0]
----

== Helidon Config

The data repository must be configured before you begin. In the example below Helidon Config is used to set up data repository
with EclipseLink and MySQL database:
[source,yaml]
----
data:
  persistence-units:
    jakarta:
      - connection:
          username: "user"
          password: "password"
          url: "jdbc:mysql://localhost:3306/pets"
          jdbc-driver-class-name: "com.mysql.cj.jdbc.Driver"
          # EclipseLink properties
          properties:
            eclipselink.target-database: "MySQL"
            eclipselink.target-server: "None"
            jakarta.persistence.schema-generation.database.action: "none"
----

== SE Application

Data repository runtime initialization is handled by service registry. Repository interface instances can be obtained using
service registry API:

[source,java]
----
include::{sourcedir}/se/data/PetService.java[tag=repository_init, indent=0]
----

== Repository Interface

Data repository interfaces are interfaces annotated with the `@Data.Repository` annotation and extending `Data.GenericRepository`
interface.
The `@Data.Repository` annotation has no argument. The `Data.GenericRepository` has no methods, but has two generic arguments
`E` and `ID`. Argument `E` is the type of the persistence entity and argument `ID` is the type of entity primary key attribute.
Composite primary keys are not supported.

The `Data.GenericRepository` interface is extended by additional interfaces to add specific features:

[cols=2*]
|===
|Interface |Description

|`Data.GenericRepository<E, ID>`
|Root interface with entity type and primary key type as generic arguments.

|`Data.BasicRepository<E, ID>`
|Extends `GenericRepository`, adds set of basic entity life-cycle operations.

|`Data.CrudRepository<E, ID>`
|Extends `BasicRepository`, adds `insert` and `update` methods to contain full set of CRUD operations.

|`Data.PageableRepository<E, ID>`
|Extends `GenericRepository`, adds pagination support.
|===

=== Repository Interface Methods

Repository interface can contain three kinds of methods:

* methods inherited from an ancestor interface
* methods with query defined by `@Data.Query` annotation
* methods with query defined by method name

Following `PetRepository` interface contains all kinds of methods: methods inherited from `CrudRepository` interface, methods
`findByName` and `listNameOrderByName` with query defined by method name and finally method `listPetsByCategory` with query defined
by `@Data.Query` annotation:

[source,java]
----
include::{sourcedir}/se/data/PetRepository.java[tag=PetRepository_class, indent=0]
----

==== Method with query defined by `@Data.Query` annotation

This kind of method requires `@Data.Query` annotation to be always present on the method. `@Data.Query` annotation has single
`String` argument with the database query. Currently only JPQL is supported as the database query.
Method arguments must match the data query arguments:

* in case of named arguments, each named argument from the query must have corresponding argument of the same name in method
  arguments. Method arguments can be in any order.

[source,java]
----
include::{sourcedir}/se/data/PetRepository.java[tag=listPets_method, indent=0]
----

* in case of indexed arguments, each indexed argument from the query must have argument in corresponding order in method
arguments. Arguments are indexed from '1'.

[source,java]
----
include::{sourcedir}/se/data/PetRepositorySnippets.java[tag=selectKeeper_method, indent=0]
----

Supported return types are

* the query row types (entity class, entity attribute class, additional query result types),
* List, Collection, Stream and Optional with query row type as generic argument
* and Page or Slice with query row type as generic argument.

==== Method with query defined by method name

This kind of method defines the query by the name of the method. Method has no query specific annotation and its name must
follow _query by method name_ specific grammar:

[source,text]
----
        method-name  :: <query> | <delete>

        query        :: <action> [ <projection> ] [ "By" <criteria>  [ "OrderBy" <order> ] ]
                            | <all-action> "All" [ "OrderBy" <order> ]
        delete       :: <del-action> "By" <criteria> ] | <del-action> [ "All" ]

        action       :: <action-l> | <prefix> <action-u>
        all-action   :: <all-action-l> | [ <prefix> ] <all-action-u>
        del-action   :: "delete" | [ <prefix> ] "Delete"

        prefix       :: [a-zA-Z0-9]*
        action-l     :: "count" |  "exists" | "get" | <all-action-l>
        action-u     :: "Count" |  "Exists" | "Get" | <all-action-u>
        all-action-l :: "find" | "list" | "stream"
        all-action-u :: "Find" | "List" | "Stream"

        projection   :: [ <expression> ] [ <property> ]
        expression   :: "First" <number> [ "Distinct" ] | "Distinct"
                            | "Max" | "Min" | "Sum" | "Avg"
        property     :: <identifier> [ "_" <identifier> ]
        identifier   :: [a-zA-Z][a-zA-Z0-9]*
        number       :: [0-9]+

        criteria     :: <condition> { <logical-operator> <condition> }
        condition    :: <property> [ [ "Not" ] [ "IgnoreCase" ] <operator>  ]
        operator     :: "After" | "Before" | Contains" | "EndsWith" | "StartsWith" | "Equal"
                            | "LessThan" | "LessThanEqual" | "GreaterThan" | "GreaterThanEqual"
                            | "Between" | "Like" | "In" | "Empty" | "Null" | "True" | "False"
        logical-operator :: "And" | "Or"

        order        :: <property> [ <direction> [ <order> ] ]
        direction    :: "Asc" | "Desc"
----

===== Method name prefix and return type

Method can have user defined prefix. The prefix is sequence of letters and digits not matching `<action-u>` keyword. This prefix
has no influence on the query. Prefix can be used to distinguish between methods with the same query but different result type.
If prefix is used, the following query action keyword must start with capital letter.

[source,java]
----
include::{sourcedir}/se/data/PetRepositorySnippets.java[tag=qbmn_method, indent=0]
----

Return type of the method depends on action keyword being used.

[cols=3*]
|===
|Keyword |Types |Description

|count
|numeric type
|Number of rows matching the query criteria.

|exists
|`boolean` or `Boolean`
|Whether at least one row matching the query criteria exists.

|get
|query row type
|Single row from the database, throws an exception when result is not a single row.

|find
|`Optional` of query row type
|Empty result or single row from the database, throws an exception when result returns more than a single row .

|list
|`Collection` or `List` of query row type
|List of rows from the database.

|list
|`Slice` or `Page` of query row type
|Pageable result of rows from the database.

|stream
|`Stream` of query row type
|Stream of rows from the database.
|===

NOTE: Validation of the keyword and return type mapping is not fully implemented so current code generator is less restrictive.
      But this may change in next releases.

===== Projection part of the query

Projection part of the method name is optional and may follow right after the return type keyword. The projection consists
of 2 parts, `expression` and `property`.

The expression keywords are:

[cols=3*]
|===
|Keyword |Example |Description

|Distinct
|`listDistinctNameByTrainer_Name`
|Only different values are returned.

|First<number>
|`listFirst10ByAge`
|Returns up to `<number>` of database rows.

|Min
|`getMinPoints`
|Returns minimum value of entity property. Requires numeric type.

|Max
|`getMaxPoints`
|Returns maximum value of entity property. Requires numeric type.

|Sum
|`getSumPoints`
|Returns sum of all entity property values. Requires numeric type.

|Avg
|`getAvgPoints`
|Returns average value of all entity properties values. Requires floating point type.
|===

Property is the entity property. The property is composed of the entity properties names separated by '_' character, e.g.
`Keeper_Name` of the `Pet` entity will be translated to `SELECT p.keeper.name FROM Pet p` JPQL query.

[source,java]
----
include::{sourcedir}/se/data/SimpleSnippets.java[tag=simple_model, indent=0]
----

===== Criteria part of the query

Criteria part of the method name is optional and represents the `WHERE` clause of the database query. It is a logical expression
composed of individual conditions joined by `AND` and `OR` logical operators.
Single criteria condition is the `property` which may be followed by set of criteria keywords. E.g. `NameIgnoreCaseNotEndsWith`
which consists of the entity property `name` and `IgnoreCase`, `Not` and `EndsWith` keywords.

Criteria condition keywords are of 2 types:

* `IgnoreCase` and `Not` modifiers which can be used before the condition keyword
* the condition keyword, for example `EndsWith`

The condition keyword can consume method arguments. Each keyword has exact number of arguments being consumed. Method arguments
are being consumed in the same order as is the order of the condition keywords in the method name.

Criteria condition modifiers:

[cols=2*]
|===
|Keyword |Description

|Not
|Negates following criteria condition .

|IgnoreCase
|Makes following criteria condition case-insensitive.
|===

Criteria condition keywords:

[cols=3*]
|===
|Keyword |Arguments |Description

|After
|1
|The property value is after the given value.

|Before
|1
|The property value is before the given value.

|Contains
|1
|The property value contains the given value. Requires `String` property and method argument.

|EndsWith
|1
|The property value ends with the given value. Requires `String` property and method argument.

|StartsWith
|1
|The property value starts with the given value. Requires `String` property and method argument.

|Equal
|1
|The property value is equal to the given value.

|LessThan
|1
|The property value is less than the given value. Requires `Comparable` property and method argument.

|LessThanEqual
|1
|The property value is less than or equal to the given value. Requires `Comparable` property and method argument.

|GreaterThan
|1
|The property value is greater than the given value. Requires `Comparable` property and method argument.

|GreaterThanEqual
|1
|The property value is greater than or equal to the given value. Requires `Comparable` property and method argument.

|Between
|2
|The property value is between the given values. Requires `Comparable` properties and method arguments.

|Like
|1
|The property value is `LIKE` the given value, equivalent to JPQL `LIKE` keyword. Requires `String` property and method argument.

|In
|1
|The property value is in the given collection. Requires `Collection<T>` method argument and property of type `T`.

|Empty
|0
|The property value is empty. Requires `Collection` property.

|Null
|0
|The property value is `NULL`.

|True
|0
|The property value is `true`. Requires `boolean` or `Boolean` property.

|False
|0
|The property value is `false`. Requires `boolean` or `Boolean` property.
|===

Logical operators:

[cols=2*]
|===
|Keyword |Description

|And
|Logical `AND` of conditions before and after the operator.

|Or
|Logical `OR` of conditions before and after the operator.
|===

Logical operators precedence in JPQL is defined in Jakarta Persistence 3.1 specification, chapter _4.6.6. Operators and Operator
Precedence_: operator `AND` has higher precedence than `OR`.

===== Sorting part of the query

Sorting part of the method name is optional and represents the `ORDER BY` clause of the database query. It is list of sorting
rules. Single sorting rule is the property followed by optional order direction keyword.
If more than one sorting rule is present, rules must be separated by the order direction keywords so only the last keyword
is optional.

Ordering keywords:

[cols=2*]
|===
|Keyword |Description

|Asc
|Returned collection is sorted in ascending order.

|Desc
|Returned collection is sorted in descending order.
|===

Default `Asc` keyword is applied when missing after the `property`.

An example of repository method with sorting:

[source,java]
----
include::{sourcedir}/se/data/PetRepositorySnippets.java[tag=qbmn_sort_method, indent=0]
----

== Pagination

Pagination allows user to split returned data collection into individual pages. When pagination is used, the repository method
must have an argument of `PageRequest` type. Return type of the method is `Slice` or `Page`.
The `PageRequest` argument of the method defines size of the page and index of the page (starting from `0`) to be returned.

Returned page content types:

[cols=2*]
|===
|Name |Description

|Slice
|Contains page data as `List` or `Stream` and `PageRequest` to return this page.

|Page
|Contains page data as `List` or `Stream`, total size of the result across all pages and `PageRequest` to return this page.
|===

An example of repository method with pagination:

[source,java]
----
include::{sourcedir}/se/data/PetRepositorySnippets.java[tag=qbmn_slice_method, indent=0]
----

== Dynamic Sorting

Sorting part of the method name defines static sorting rule which cannot be modified in runtime. Dynamic sorting allows user
to define additional sorting rule which is defined at runtime. Dynamic sorting is triggered by adding an argument of `Sort`
type to the repository method. Both rules can be used simultaneously.

An example of repository method with dynamic sorting:

[source,java]
----
include::{sourcedir}/se/data/PetRepositorySnippets.java[tag=qbmn_dynamic_sort_method, indent=0]
----

Static sorting rules from the method name are always applied first and dynamic rules are added after them.

[source,java]
----
include::{sourcedir}/se/data/PetRepositorySnippets.java[tag=qbmn_dual_sort_method, indent=0]
----

== Persistence Session Access

User can get access to persistence provider session to implement more complex tasks which are not supported by this framework.
This feature is available to the data repository interface which extends `Data.SessionRepository<S>` interface. Generic argument
`S` is the persistence session type, e.g. `EntityManager`.

`Data.SessionRepository<S>` interface contains methods to provide session managed by data repository framework so there is no need
to handle session instance life-cycle.

[source,java]
----
include::{sourcedir}/se/data/SimpleSnippets.java[tag=session_repository, indent=0]
----

Now EntityManager instance is available through Data.SessionRepository<EntityManager> interface methods:

[source,java]
----
include::{sourcedir}/se/data/PetService.java[tag=session_access, indent=0]
----

NOTE: `EntityManager` instance is valid only while `call` method is being executed. This instance must not be stored and used after
      this method has ended.
