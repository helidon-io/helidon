///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2025 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Declarative

:description: Helidon SE Declarative
:keywords: helidon, se, injection, declarative
:h1Prefix: SE
:feature-name: Declarative
:rootdir: {docdir}/../..

include::{rootdir}/includes/se.adoc[]

== Contents

- <<Overview, Overview>>
- <<Usage, Usage>>
- <<Features, Features>>

== Overview

Helidon declarative programming model allows inversion of control style programming with all the performance benefits of Helidon SE.

Our declarative approach has the following advantages:

- Uses Helidon SE imperative code to implement features (i.e. performance is same as "pure" imperative application)
- Generates all the necessary code at build-time, to avoid reflection and bytecode manipulation at runtime
- It is based on xref:injection.adoc#Overview[Helidon Injection]
- Declarative features are in the same modules as Helidon SE features (i.e. does not require additional dependencies)

[NOTE]
Helidon Declarative is an incubating feature. The APIs shown here are subject to change. These APIs will be finalized in a future release of Helidon.

== Usage

To create a declarative application, use the annotations provided in our Helidon SE modules (details under <<Features, Features>>), and the maven plugin
described in xref:injection.adoc#generate-binding[Injection: Startup] to generate the binding.

In addition, the following section must be added to the `build` of the Maven `pom.xml` to enable annotation processors that generate the necessary code:

[source,xml]
----
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
            <annotationProcessorPaths>
                <path>
                    <groupId>io.helidon.bundles</groupId>
                    <artifactId>helidon-bundles-apt</artifactId>
                    <version>${helidon.version}</version>
                </path>
            </annotationProcessorPaths>
        </configuration>
    </plugin>
</plugins>
----


== Features

The following features are currently implemented:

- <<Dec-Config, Configuration>>
- <<Dec-HTTP-Server, HTTP Server Endpoint>>
- <<Dec-HTTP-Client, Typed HTTP Client>>
- <<Dec-FT, Fault Tolerance>>
- <<Dec-Scheduling, Scheduling>>
- <<Dec-Validation, Validation>>

A Helidon Declarative application should be started using the generated application binding, to ensure no lookup and no reflection.
The call to `ServiceRegistryManager.start` ensures that all services with a defined `RunLevel` are started, including Helidon WebServer, Scheduled services etc.

[source,java]
.Example of a declarative main class
----
include::{sourcedir}/se/inject/DeclarativeExample.java[tag=snippet_1, indent=0]
----

=== Configuration [[Dec-Config]]

Configuration can be injected as a whole into any service, or a specific configuration option can be injected using `@Configuration.Value`. Default values can be defined using annotations in `@Default`

Services available for injection:

- link:{config-javadoc-base-url}/io/helidon/config/Config.html[`io.helidon.config.Config`]

Annotations:

- link:{config-javadoc-base-url}/io/helidon/config/Configuration.html[`io.helidon.config.Configuration.Value`] - define the configuration key to inject, on constructor parameter
- Annotations defined in link:{common-javadoc-base-url}/io/helidon/common/Default.html[`io.helidon.common.Default`] - define a default typed value, on the same constructor parameter

Example of usage can be seen below in HTTP Server Endpoint example.

=== HTTP Server Endpoint [[Dec-HTTP-Server]]

To create an HTTP endpoint, simply annotate a class with `@RestServer.Endpoint`, and
add at least one method annotated with one of the HTTP method annotations, such as `@Http.GET`.

Services available for injection:

N/A

Supported method parameters (no annotation required):

- link:{webserver-javadoc-base-url}/io/helidon/webserver/http/ServerRequest.html[`io.helidon.webserver.http.ServerRequest`]
- link:{webserver-javadoc-base-url}/io/helidon/webserver/http/ServerResponse.html[`io.helidon.webserver.http.ServerResponse`]
- link:{context-javadoc-base-url}/io/helidon/common/context/Context.html[`io.helidon.common.context.Context`]
- `io.helidon.common.security.SecurityContext`
- link:{security-javadoc-base-url}/io/helidon/security/SecurityContext.html`[`io.helidon.security.SecurityContext] - in case `helidon-security` module is on the classpath

Annotations on endpoint type:

- link:{webserver-javadoc-base-url}/io/helidon/webserver/http/RestServer.Endpoint.html[`io.helidon.webserver.http.RestServer.Endpoint`] - required annotation
- link:{webserver-javadoc-base-url}/io/helidon/webserver/http/RestServer.Listener.html[`io.helidon.webserver.http.RestServer.Listener`] - to define the named listener this should be served on (named port/socket)
- link:{webserver-javadoc-base-url}/io/helidon/webserver/http/RestServer.Header.html[`io.helidon.webserver.http.RestServer.Header`] - header to return with each response from this endpoint
- link:{webserver-javadoc-base-url}/io/helidon/webserver/http/RestServer.ComputedHeader.html[`io.helidon.webserver.http.RestServer.ComputedHeader`] - computed header to return with each response from this endpoint
- link:{http-javadoc-base-url}/io/helidon/http/Http.Path.html[`io.helidon.http.Http.Path`] - path (context) this endpoint will be available on

Annotations on endpoint methods:

- link:{webserver-javadoc-base-url}/io/helidon/webserver/http/RestServer.Header.html[`io.helidon.webserver.http.RestServer.Header`] - header to return with each response from this method
- link:{webserver-javadoc-base-url}/io/helidon/webserver/http/RestServer.ComputedHeader.html[`io.helidon.webserver.http.RestServer.ComputedHeader`] - computed header to return with each response from this method
- link:{webserver-javadoc-base-url}/io/helidon/webserver/http/RestServer.Status.html[`io.helidon.webserver.http.RestServer.Status`] - status to return (if a custom one is required)
- link:{http-javadoc-base-url}/io/helidon/http/Http.Path.html[`io.helidon.http.Http.Path`] - path (context) this method will be available on (subpath of the endpoint path)
- link:{http-javadoc-base-url}/io/helidon/http/Http.GET.html[`io.helidon.http.Http.GET`] (and other methods) - definition of HTTP method this method will serve
- link:{http-javadoc-base-url}/io/helidon/http/Http.HttpMethod.html[`io.helidon.http.Http.HttpMethod`] - for custom HTTP method names (mutually exclusive with above)
- link:{http-javadoc-base-url}/io/helidon/http/Http.Produces.html[`io.helidon.http.Http.Produces`] - what media type this method produces (return entity content type)
- link:{http-javadoc-base-url}/io/helidon/http/Http.Consumes.html[`io.helidon.http.Http.Consumes`] - what media type this method accepts (request entity content type)

Annotations on method parameters:

- link:{http-javadoc-base-url}/io/helidon/http/Http.Entity.html[`io.helidon.http.Http.Entity`] - Request entity, a typed parameter is expected, will use HTTP media type modules to coerce into the correct type
- link:{http-javadoc-base-url}/io/helidon/http/Http.HeaderParam.html[`io.helidon.http.Http.HeaderParam`] - Typed HTTP request header value
- link:{http-javadoc-base-url}/io/helidon/http/Http.QueryParam.html[`io.helidon.http.Http.QueryParam`] - Typed HTTP query value
- link:{http-javadoc-base-url}/io/helidon/http/Http.PathParam.html[`io.helidon.http.Http.PathParam`] - Typed parameter from path template

[source,java]
.Example of an HTTP Server Endpoint
----
include::{sourcedir}/se/inject/DeclarativeExample.java[tag=snippet_2, indent=0]
----

=== Typed HTTP Client [[Dec-HTTP-Client]]

To create a typed HTTP client, create an interface annotated with `RestClient.Endpoint`, and at least one method annotated
with one fo the HTTP method annotations, such as `@Http.GET`. Methods can only have parameters annotated with one of the
`Http` qualifiers.

Annotations on endpoint type:

- link:{webclient-api-javadoc-base-url}/io/helidon/webclient/api/RestClient.Endpoint.html[`io.helidon.webclient.api.RestClient.Endpoint`] - required annotation
- link:{http-javadoc-base-url}/io/helidon/http/Http.Path.html[`io.helidon.http.Http.Path`] - path (context) the server listens on
- link:{webclient-api-javadoc-base-url}/io/helidon/webclient/api/RestClient.Header.html[`io.helidon.webclient.api.RestClient.Header`] - header to include in every request to the server
- link:{webclient-api-javadoc-base-url}/io/helidon/webclient/api/RestClient.ComputedHeader.html[`io.helidon.webclient.api.RestClient.ComputedHeader`] - header to compute and include in every request to the server

Annotations on endpoint methods:

- link:{webclient-api-javadoc-base-url}/io/helidon/webclient/api/RestClient.Header.html[`io.helidon.webclient.api.RestClient.Header`] - header to include in every request to the server
- link:{webclient-api-javadoc-base-url}/io/helidon/webclient/api/RestClient.ComputedHeader.html[`io.helidon.webclient.api.RestClient.ComputedHeader`] - header to compute and include in every request to the server
- link:{http-javadoc-base-url}/io/helidon/http/Http.Path.html[`io.helidon.http.Http.Path`] - path (context) the server serves this endpoint method on
- link:{http-javadoc-base-url}/io/helidon/http/Http.GET.html[`io.helidon.http.Http.GET`] (and other methods) - definition of HTTP method this method will invoke
- link:{http-javadoc-base-url}/io/helidon/http/Http.HttpMethod.html[`io.helidon.http.Http.HttpMethod`] - for custom HTTP method names (mutually exclusive with above)
- link:{http-javadoc-base-url}/io/helidon/http/Http.Produces.html[`io.helidon.http.Http.Produces`] - what media type this method produces (content type of entity from the server)
- link:{http-javadoc-base-url}/io/helidon/http/Http.Consumes.html[`io.helidon.http.Http.Consumes`] - what media type this method accepts (request entity content type)

Annotations on method parameters:

- link:{http-javadoc-base-url}/io/helidon/http/Http.Entity.html[`io.helidon.http.Http.Entity`] - Request entity, a typed parameter is expected, will use HTTP media type modules to write to the request
- link:{http-javadoc-base-url}/io/helidon/http/Http.HeaderParam.html[`io.helidon.http.Http.HeaderParam`] - Typed HTTP header value to send
- link:{http-javadoc-base-url}/io/helidon/http/Http.QueryParam.html[`io.helidon.http.Http.QueryParam`] - Typed HTTP query value to send
- link:{http-javadoc-base-url}/io/helidon/http/Http.PathParam.html[`io.helidon.http.Http.PathParam`] - Typed parameter from path template to construct the request URI

[source,java]
.Example of a Typed HTTP Client
----
include::{sourcedir}/se/inject/DeclarativeExample.java[tag=snippet_3, indent=0]
----


=== Fault Tolerance [[Dec-FT]]

Fault tolerance annotations allow adding features to methods on services.
The annotations can be added to any method that supports interception (i.e. methods that are not private).

Method Annotations:

- link:{faulttolerance-javadoc-base-url}/io/helidon/faulttolerance/Ft.Retry.html[`io.helidon.faulttolerance.Ft.Retry`] - allow retries
- link:{faulttolerance-javadoc-base-url}/io/helidon/faulttolerance/Ft.Fallback.html[`io.helidon.faulttolerance.Ft.Fallback`] - fallback to another method that provides
- link:{faulttolerance-javadoc-base-url}/io/helidon/faulttolerance/Ft.Async.html[`io.helidon.faulttolerance.Ft.Async`] - invoke method asynchronously
- link:{faulttolerance-javadoc-base-url}/io/helidon/faulttolerance/Ft.Timeout.html[`io.helidon.faulttolerance.Ft.Timeout`] - invoke method with a timeout
- link:{faulttolerance-javadoc-base-url}/io/helidon/faulttolerance/Ft.Bulkhead.html[`io.helidon.faulttolerance.Ft.Bulkhead`] - use bulkhead
- link:{faulttolerance-javadoc-base-url}/io/helidon/faulttolerance/Ft.CircuitBreaker.html[`io.helidon.faulttolerance.Ft.CircuitBreaker`] - use circuit breaker

[source,java]
.Example of Fault Tolerance Fallback
----
include::{sourcedir}/se/inject/DeclarativeExample.java[tag=snippet_4, indent=0]
----

=== Scheduling [[Dec-Scheduling]]

Scheduling allows service methods to be invoked periodically.

Method annotations:

- link:{scheduling-se-javadoc-base-url}/io/helidon/scheduling/Scheduling.Cron.html[`io.helidon.scheduling.Scheduling.Cron`] - execute with schedule defined by a CRON expression
- link:{scheduling-se-javadoc-base-url}/io/helidon/scheduling/Scheduling.FixedRate.html[`io.helidon.scheduling.Scheduling.FixedRate`] - execute with a fixed interval

[source,java]
.Example of a fixed rate scheduled method
----
include::{sourcedir}/se/inject/DeclarativeExample.java[tag=snippet_5, indent=0]
----

=== Validation [[Dec-Validation]]

Validation provides an ability to validate service method parameters and return types.
This is achieved through constraint annotations and type validation.

To use validation, the proper dependency must be added to your `pom.xml`, and an annotation processor must be configured to
code generate the required classes. The annotation processor is part of the bundle mentioned in Helidon Declarative introduction
above.

Helidon validation module:
[source, xml]
----
<dependency>
    <groupId>io.helidon.validation</groupId>
    <artifactId>helidon-validation</artifactId>
</dependency>
----

==== Constraint Annotations

A "Constraint Annotation" is any annotation directly annotated with `io.helidon.validation.Validation`.
Helidon Validation provides a set of built-in validation constraints, though custom constraints can be created, or existing constraints can be combined.

Existing constraints:

Constraints for any type:

- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.NotNull.html[`io.helidon.validation.Validation.NotNull`] - must not be null
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Null.html[`io.helidon.validation.Validation.Null`] - must be null

Constraints for `String` and `CharSequence`:

- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.String.Email.html[`io.helidon.validation.Validation.Email`] - matches an e-mail structure (basic check only)
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.String.NotBlank.html[`io.helidon.validation.Validation.String.NotBlank`] - must not be blank (empty or only white-space characters)
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.String.NotEmpty.html[`io.helidon.validation.Validation.String.NotEmpty`] - must not be empty (i.e. length is `0`)
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.String.Length.html[`io.helidon.validation.Validation.String.Length`] - check for maximal (and optionally minimal) length
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.String.Pattern.html[`io.helidon.validation.Validation.String.Pattern`] - check against a regular expression

Constraints for types that extend `java.lang.Number`. These constraints accept any such type, though all types are eventually converted to a `BigDecimal` and the checks are done against the result.
`Byte` is always converted as an unsigned number, i.e. its values are from `0` to `255` inclusive.

- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Number.Negative.html[`io.helidon.validation.Validation.Number.Negative`] - the value must be negative (`< 0`)
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Number.NegativeOrZero.html[`io.helidon.validation.Validation.Number.NegativeOrZero`] - the value must be negative or zero (`&lt;= 0`)
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Number.Positive.html[`io.helidon.validation.Validation.Number.Positive`] - the value must be positive (`> 0`)
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Number.PositiveOrZero.html[`io.helidon.validation.Validation.Number.PositiveOrZero`] - the value must be positive or zero (`>= 0`)
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Number.Min.html[`io.helidon.validation.Validation.Number.Min`] - the value must be at least the specified minimal value (`>= min`), value is defined as a `String`
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Number.Max.html[`io.helidon.validation.Validation.Number.Max`] - the value must be at most the specified maximal value (`&lt;= max`), value is defined as a `String`
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Number.Digits.html[`io.helidon.validation.Validation.Number.Digits`] - the number must have at most the specified number of integer and fractional digits

Constraints for `Integer` data types. These constraints accept `int, long, byte, char, short` and their boxed counterparts.
`byte` is always converted as an unsigned number, i.e. its values are from `0` to `255` inclusive.
These are convenience annotation that use `int` data type:

- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Integer.Min.html[`io.helidon.validation.Validation.Integer.Min`] - the value must be at least the specified minimal value (`>= min`)
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Integer.Max.html[`io.helidon.validation.Validation.Integer.Max`] - the value must be at most the specified maximal value (`&lt;= max`)

Constraints for `Long` and `long` data types. No other type is supported:

- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Long.Min.html[`io.helidon.validation.Validation.Long.Min`] - the value must be at least the specified minimal value (`>= min`)
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Long.Max.html[`io.helidon.validation.Validation.Long.Max`] - the value must be at most the specified maximal value (`&lt;= max`)

Constraints for `Boolean` and `boolean` data type. No other type is supported:

- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Boolean.True.html[`io.helidon.validation.Validation.Boolean.True`] - the value must be `true`
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Boolean.False.html[`io.helidon.validation.Validation.Boolean.False`] - the value must be `false`

Constraints for collection and map data types:

- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Collection.Size.html[`io.helidon.validation.Validation.Collection.Size`] - the size of the collection or map must be between the minimal and maximal sizes

Constraints for calendar/time data types. Behavior depends on the specific type - for example for `Year` data type, past is previous year,
future is the next year, and present is the current year, regardless of which month it is. When using `Instant`, past is already the last millisecond.

- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Calendar.Future.html[`io.helidon.validation.Validation.Calendar.Future`] - the value must be in the future
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Calendar.FutureOrPresent.html[`io.helidon.validation.Validation.Calendar.FutureOrPresent`] - the value must be in the future or now
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Calendar.Past.html[`io.helidon.validation.Validation.Calendar.Past`] - the value must be in the past
- link:{validation-javadoc-base-url}/io/helidon/validation/Validation.Calendar.PastOrPresent.html[`io.helidon.validation.Validation.Calendar.PastOrPresent`] - the value must be in the past or now

Supported types for calendar/time validations:

- `java.util.Date`
- `java.util.Calendar`
- `java.time.Instant`
- `java.time.LocalDate`
- `java.time.LocalDateTime`
- `java.time.LocalTime`
- `java.time.MonthDay`
- `java.time.OffsetDateTime`
- `java.time.OffsetTime`
- `java.time.Year`
- `java.time.YearMonth`
- `java.time.ZonedDateTime`
- `java.time.chrono.HijrahDate`
- `java.time.chrono.JapaneseDate`
- `java.time.chrono.MinguoDate`
- `java.time.chrono.ThaiBuddhistDate`


==== Type Validation

A type annotated with `@Validation.Validated` will have validation code generated. Usage of that type can be marked with
`@Validation.Valid` - if such an annotation is present, and it is on a field of another validated type, or it is a parameter,
return type, or a type argument of a parameter/return type of a service method, the object instance will be validated using
a generated interceptor.

==== Usage

[source,java]
.Example of a validated type
----
include::{sourcedir}/se/ValidationSnippets.java[tag=snippet_1, indent=0]
----

[source,java]
.Example of a validated method call using a validated type
----
include::{sourcedir}/se/inject/DeclarativeExample.java[tag=snippet_7, indent=0]
----

A custom "compound" annotation can be created to simplify usage.

[source,java]
.Example of a compound annotation
----
include::{sourcedir}/se/inject/DeclarativeExample.java[tag=snippet_8, indent=0]
----

A custom constraint annotation can be created (and act as a compound annotation as well).

[source,java]
.Example of a custom constraint annotation
----
include::{sourcedir}/se/inject/DeclarativeExample.java[tag=snippet_9, indent=0]
----

For each constraint annotation, there MUST be a service that validates it.

[source,java]
.Example of constraint validation provider
----
include::{sourcedir}/se/inject/DeclarativeExample.java[tag=snippet_10, indent=0]
----
