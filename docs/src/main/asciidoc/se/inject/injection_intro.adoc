///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2023, 2024 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Helidon Injection
:description: about Helidon Injection
:keywords: helidon, inject, injection, java, microservices, virtual threads
:feature-name: Helidon Injection
:rootdir: {docdir}/..

== Contents

- <<Overview, Overview>>
- <<Maven Coordinates, Maven Coordinates>>
- <<Usage, Usage>>
- <<Creating Services, Creating Services>>

== Overview

Helidon Injection is an optional feature in Helidon that provides service registry, a lifecycle engine and extensibility for customized code generation.

NOTE: Helidon Injection provides a way to develop non Helidon-specific declarative code

The Helidon Injection Framework provides a mix of declarative and programmatic ways to build your application.
Helidon Injection's minimalist, compile-time generated dependency injection (DI) framework and compile-time source code generation has a number of advantages, including:

* enables declarative, Inversion of Control-style programming
* offers visibility into your application by providing "less magic" - understandability and debug-ability of your application
* provides deterministic behavior (instead of depending on reflection and classpath ordering, etc.)
* optimizes performance improvements since binding the model at compile-time is more efficient than computing it at runtime.

== Maven Coordinates

.Injection dependencies
[source,xml]
----
<dependency>
    <groupId>io.helidon.inject</groupId>
    <artifactId>helidon-inject</artifactId>
    <version>${helidon.version}</version>
</dependency>
----

== Usage

Once you have planned how each of your resources should support Injection, you annotate your service types
(see <<_creating_services, Creating Services>>), add annotation processor to generate the Helidon specific sources
(see <<_code_generation_configuration, Code generation>>).

Then at runtime, you simply need to trigger your starting services by looking them up from the registry, and either
"just" obtaining an instance, or calling some methods on them, such as:

[source,java]
----
// create new service registry manager
InjectionServices registryManager = InjectionServices.create();
// get the service registry
Services services = registryManager.services();
// query
Supplier<MyService> serviceSupplier = services.supply(MyService.class);
// lazily activate
MyService myLazyActivatedService = serviceSupplier.get();
----

[#_creating_services]
== Creating Services

When creating a module that may provide services (or just contracts) that could be used by the service registry at runtime, you need to declare a dependency, annotation processor, and update your sources.

=== Maven Coordinates

.Injection Service pom.xml
[source,xml]
----
<dependency>
 <groupId>io.helidon.inject</groupId>
 <artifactId>helidon-inject-service</artifactId>
</dependency>
----

=== Types

The Injection Service API provides types that are generally useful at compile time to assign special meaning to the type.
In this way it also helps with readability and intentions of the code itself.
The library also contains all types that are required to compile the generated sources, and the `ServiceLoader` API that is provided by your module

All types listed bellow are inner types of `io.helidon.inject.service.Injection`.

* `Contract` - signifies that the type can be used for lookup in the service registry
* `ExternalContracts` - same as Contract, but applied to the implementation class instead, marking other interfaces as contracts
* `RunLevel` - ascribes meaning for when the service should start
* `Inject` - equivalent of Jakarta `@Inject` annotation, that marks a field, method, or constructor as injection receiver
* `Qualifier` - equivalent of Jakarta `@Qualifier` annotation, marks a qualifier annotation
* `Named` - equivalent of Jakarta `@Named` annotation, a qualifier that names a service instance (and `ClassNamed` is a specific `Named` class that uses the classes fully qualified name as the name)
* `Service` - marks a type as a service to be registered in the service registry, if no scope is defined, an instance will be created for each injection point (or each time the `Supplier` is called)
* `Singleton` - scope that ensures a single instance for the lifetime of the Service registry (i.e. this is not a JVM singleton)
* `RequestScope` - scope that is created for each request (intended primarily for HTTP requests)
* `PostConstruct` - post construct lifecycle method
* `PreDestroy` - pre destroy lifecycle method

[#_code_generation_configuration]
=== Code generation configuration

Once your contracts and services are correctly annotated, you need to add the following annotation processor paths

.Compiler plugin configuration
[source,xml]
----
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <configuration>
        <compilerArgs>
            <!-- possible configuration of Helidon annotation processors
            <arg>-Ahelidon.inject.autoAddNonContractInterfaces=true</arg>
            -->
        </compilerArgs>
        <annotationProcessorPaths>
            <path>
                <groupId>io.helidon.bundles</groupId>
                <artifactId>helidon-bundles-apt</artifactId>
                <version>${helidon.version}</version>
            </path>
        </annotationProcessorPaths>
    </configuration>
</plugin>
----

The bundle contains Helidon annotation processor, and all code generators supported by Helidon.
To provide a finer-grained setup, you can use:

.Compiler plugin configuration (Helidon Injection only)
[source,xml]
----
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <configuration>
        <compilerArgs>
            <!-- possible configuration of Helidon annotation processors
            <arg>-Ahelidon.inject.autoAddNonContractInterfaces=true</arg>
            -->
        </compilerArgs>
        <annotationProcessorPaths>
            <path>
                <groupId>io.helidon.codegen</groupId>
                <artifactId>helidon-codegen-apt</artifactId>
                <version>${helidon.version}</version>
            </path>
            <path>
                <groupId>io.helidon.inject</groupId>
                <artifactId>helidon-inject-codegen</artifactId>
                <version>${helidon.version}</version>
            </path>
        </annotationProcessorPaths>
    </configuration>
</plugin>
----