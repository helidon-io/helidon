///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2020, 2025 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

ifndef::rootdir[:rootdir: {docdir}/..]
ifndef::sourcedir[:sourcedir: {rootdir}/../java/io/helidon/docs]

// tag::data_overview[]
Data repository queries are an abstraction over Object–Relational Mapping, or ORM. This enables
interfaces with query definitions to be translated into implementation classes at compile time.

The Helidon Data Repository is built on Jakarta Persistence and supports major providers such as
EclipseLink and Hibernate.

include::{rootdir}/includes/dependencies.adoc[]

[source,xml]
----
<dependency>
    <groupId>io.helidon.data</groupId>
    <artifactId>helidon-data</artifactId>
</dependency>
<dependency>
    <groupId>io.helidon.data.jakarta.persistence</groupId>
    <artifactId>helidon-data-jakarta-persistence</artifactId>
</dependency>
----

The Jakarta Persistence provider (EclipseLink) and the JDBC driver (MySQL) are required at runtime.

[source,xml]
----
<dependency>
    <groupId>org.eclipse.persistence</groupId>
    <artifactId>org.eclipse.persistence.jpa</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.eclipse.persistence</groupId>
    <artifactId>org.eclipse.persistence.core</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>
----
// end::data_overview[]

// tag::data_annotation_processor[]
== Annotation Processor

Both the entity model and data repository interfaces require a specific annotation-processor configuration:

[source,xml]
----
<annotationProcessorPaths>
    <path>
        <groupId>io.helidon.bundles</groupId>
        <artifactId>helidon-bundles-apt</artifactId>
        <version>${helidon.version}</version>
    </path>
    <path>
        <groupId>io.helidon.data.codegen</groupId>
        <artifactId>helidon-data-codegen</artifactId>
        <version>${helidon.version}</version>
    </path>
    <path>
        <groupId>io.helidon.data.jakarta.persistence</groupId>
        <artifactId>helidon-data-jakarta-persistence-codegen</artifactId>
        <version>${helidon.version}</version>
    </path>
</annotationProcessorPaths>
----
// end::data_annotation_processor[]

// tag::data_usage[]
== Usage

The Data Repository provides an API and tooling for implementing database queries through interface method
prototypes.

There are two ways in which such a query can be defined:

* using a method annotated with `@Data.Query`

[source,java]
----
include::{sourcedir}/includes/data/PetRepository.java[tag=listPets_method, indent=0]
----

* using the method name as the query definition

[source,java]
----
include::{sourcedir}/includes/data/PetRepository.java[tag=findByName_method, indent=0]
----
// end::data_usage[]

// tag::data_config[]
== Helidon Config

You must configure the data repository before using it.

In the example below, Helidon Config sets up the data repository using the EclipseLink
provider and a MySQL database:

[source,yaml]
----
data:
  persistence-units:
    jakarta:
      - connection:
          username: "user"
          password: "password"
          url: "jdbc:mysql://localhost:3306/pets"
          jdbc-driver-class-name: "com.mysql.cj.jdbc.Driver"
          # EclipseLink properties
          properties:
            eclipselink.target-database: "MySQL"
            eclipselink.target-server: "None"
            jakarta.persistence.schema-generation.database.action: "none"
----
// end::data_config[]

// tag::data_repository_interface[]
== Repository Interface

Data repository interfaces are annotated with `@Data.Repository` and extend the `Data.GenericRepository`
interface.

The `@Data.Repository` annotation takes no arguments. The `Data.GenericRepository` declares no methods
but has two generic type parameters, `E` and `ID`. `E` represents the persistence entity type and `ID`
represents the type of the entity's primary key attribute. Composite primary keys are not supported.

The `Data.GenericRepository` interface is extended by additional interfaces that add specific features:

[cols=2*]
|===
|Interface |Description

|`Data.GenericRepository`
|Root interface with entity type and primary key type as generic arguments.

|`Data.BasicRepository`
|Extends `GenericRepository`; adds a set of basic entity life-cycle operations.

|`Data.CrudRepository`
|Extends `BasicRepository`; adds `insert` and `update` methods to provide full CRUD support.

|`Data.PageableRepository`
|Extends `GenericRepository`; adds pagination support.
|===

=== Repository Interface Methods

A repository interface may contain three kinds of methods:

* Methods inherited from an ancestor interface
* Methods with a query defined via the `@Data.Query` annotation
* Methods with a query defined via the method name

The following `PetRepository` interface contains all of these: inherited methods from `CrudRepository`,
the methods `findByName` and `listNameOrderByName` defined by method name, and `listPetsByCategory`
defined by the `@Data.Query` annotation:

[source,java]
----
include::{sourcedir}/includes/data/PetRepository.java[tag=PetRepository_class, indent=0]
----

==== Method with query defined by `@Data.Query` annotation

This method type must always include the `@Data.Query` annotation. The annotation takes a single `String`
argument containing the database query. Currently only JPQL is supported. Method arguments must match
the query parameters:

* for named arguments, each named argument in the query must correspond to a method argument with the same name, in any order.

[source,java]
----
include::{sourcedir}/includes/data/PetRepository.java[tag=listPets_method, indent=0]
----

* for indexed arguments, each argument must appear in the same order as in the query. Indexing starts at `1`.

[source,java]
----
include::{sourcedir}/includes/data/PetRepositorySnippets.java[tag=selectKeeper_method, indent=0]
----

Supported return types include:

* The query row types such as entity class, entity attribute, or custom projection
* `List`, `Collection`, `Stream`, or `Optional` with the query row type as a generic parameter
* `Page` or `Slice` with the query row type as a generic parameter

==== Method with query defined by method name

This method type infers the query based on the method name and does not use a specific annotation.
The method name must follow the _query-by-method-name_ syntax:

[source,text]
----
        method-name  :: <query> | <delete>

        query        :: <action> [ <projection> ] [ "By" <criteria>  [ "OrderBy" <order> ] ]
                            | <all-action> "All" [ "OrderBy" <order> ]
        delete       :: <del-action> "By" <criteria> ] | <del-action> [ "All" ]

        action       :: <action-l> | <prefix> <action-u>
        all-action   :: <all-action-l> | [ <prefix> ] <all-action-u>
        del-action   :: "delete" | [ <prefix> ] "Delete"

        prefix       :: [a-zA-Z0-9]*
        action-l     :: "count" |  "exists" | "get" | <all-action-l>
        action-u     :: "Count" |  "Exists" | "Get" | <all-action-u>
        all-action-l :: "find" | "list" | "stream"
        all-action-u :: "Find" | "List" | "Stream"

        projection   :: [ <expression> ] [ <property> ]
        expression   :: "First" <number> [ "Distinct" ] | "Distinct"
                            | "Max" | "Min" | "Sum" | "Avg"
        property     :: <identifier> [ "_" <identifier> ]
        identifier   :: [a-zA-Z][a-zA-Z0-9]*
        number       :: [0-9]+

        criteria     :: <condition> { <logical-operator> <condition> }
        condition    :: <property> [ [ "Not" ] [ "IgnoreCase" ] <operator>  ]
        operator     :: "After" | "Before" | Contains" | "EndsWith" | "StartsWith" | "Equal"
                            | "LessThan" | "LessThanEqual" | "GreaterThan" | "GreaterThanEqual"
                            | "Between" | "Like" | "In" | "Empty" | "Null" | "True" | "False"
        logical-operator :: "And" | "Or"

        order        :: <property> [ <direction> [ <order> ] ]
        direction    :: "Asc" | "Desc"
----

===== Method name prefix and return type

A method can have a user-defined prefix. The prefix is a sequence of letters and digits that does not
match any `<action-u>` keyword. This prefix has no influence on the query and can be used to distinguish
between methods that have the same query but different result types. If a prefix is used, the following
query action keyword must start with a capital letter.

[source,java]
----
include::{sourcedir}/includes/data/PetRepositorySnippets.java[tag=qbmn_method, indent=0]
----

The return type depends on the action keyword:

[cols=3*]
|===
|Keyword |Return Type |Description

|count
|Numeric type
|Number of rows matching the query criteria

|exists
|`boolean` or `Boolean`
|Whether at least one matching row exists

|get
|Query row type
|Single result that throws an exception if there are zero or multiple results

|find
|`Optional<…>`
|Zero or single result that throws an exception if there are multiple results

|list
|`Collection` or `List`
|All matching rows

|list
|`Slice` or `Page`
|Pageable result set

|stream
|`Stream`
|Stream of matching rows
|===

NOTE: Validation of the keyword–return type mapping is not fully enforced by the code generator,
though this may change in future releases.

===== Projection in method name

The projection part is optional and follows directly after the return-type keyword. It consists
of `expression` and `property` components:

[cols=3*]
|===
|Keyword |Example |Description

|Distinct
|`listDistinctNameByTrainer_Name`
|Returns only unique values.

|First<number>
|`listFirst10ByAge`
|Returns up to `<number>` rows.

|Min
|`getMinPoints`
|Returns the minimum property value. Requires numeric type.

|Max
|`getMaxPoints`
|Returns the maximum property value. Requires numeric type.

|Sum
|`getSumPoints`
|Returns the sum of values. Requires numeric type.

|Avg
|`getAvgPoints`
|Returns the average value. Requires floating point type.
|===

The `property` part is the entity property name and it can contain underscores. An underscore is interpreted
as a dot, which means navigation to a related entity attribute. For example, `Keeper_Name` on the `Pet` entity
translates to the JPQL query `SELECT p.keeper.name FROM Pet p`.

[source,java]
----
include::{sourcedir}/includes/data/SimpleSnippets.java[tag=simple_model, indent=0]
----

===== Criteria in method name

Criteria part of the method name is optional and represents the `WHERE` clause of the database query. It is a logical expression
composed of individual conditions joined by `AND` and `OR` logical operators.
Single criteria condition is the `property` which may be followed by set of criteria keywords. E.g. `NameIgnoreCaseNotEndsWith`
which consists of the entity property `name` and `IgnoreCase`, `Not` and `EndsWith` keywords.

Criteria condition keywords are of 2 types:

* `IgnoreCase` and `Not` modifiers which can be used before the condition keyword
* the condition keyword, for example `EndsWith`

The condition keyword can consume method arguments. Each keyword has exact number of arguments being consumed. Method arguments
are being consumed in the same order as is the order of the condition keywords in the method name.

Criteria modifiers:

[cols=2*]
|===
|Keyword |Description

|Not
|Negates the next condition

|IgnoreCase
|Makes the next condition case-insensitive
|===

Supported condition keywords:

[cols=3*]
|===
|Keyword |Args |Description

|After
|1
|The property value is after the given value

|Before
|1
|The property value is before the given value

|Contains
|1
|The property value contains the given value. Requires a `String` property and argument

|EndsWith
|1
|The property value ends with the given value. Requires a `String` property and argument

|StartsWith
|1
|The property value starts with the given value. Requires a `String` property and argument

|Equal
|1
|The property value is equal to the given value

|LessThan
|1
|The property value is less than the given value. Requires a `Comparable` property and argument

|LessThanEqual
|1
|The property value is less or equal to the given value. Requires a `Comparable` property and argument

|GreaterThan
|1
|The property value is greater than the given value. Requires a `Comparable` property and argument

|GreaterThanEqual
|1
|The property value is greater or equal to the given value. Requires a `Comparable` property and argument

|Between
|2
|The property value is between the given values. Requires `Comparable` properties and arguments

|Like
|1
|The property value is `LIKE` the given value. Requires a `String` property and argument

|In
|1
|The property value is in the given collection. Requires a `Collection` argument

|Empty
|0
|The property value is empty. Requires a `Collection` property

|Null
|0
|The property value is `NULL`

|True
|0
|The property value is `true`. Requires `boolean` or `Boolean` property

|False
|0
|The property value is `false`
|===

Logical operators:

[cols=2*]
|===
|Keyword |Description

|And
|Logical AND

|Or
|Logical OR
|===

In JPQL, operator precedence places `AND` above `OR` as defined in Jakarta Persistence 3.1 section 4.6.6.

===== Ordering in method name

Ordering part of the method name is optional and represents the `ORDER BY` clause of the database query. It is list of ordering
rules. Single ordering rule is the property followed by optional order direction keyword.
If more than one ordering rule is present, rules must be separated by the order direction keywords so only the last keyword
is optional.

Ordering keywords:

[cols=2*]
|===
|Keyword |Description

|Asc
|Returned collection is sorted in ascending order.

|Desc
|Returned collection is sorted in descending order.
|===

Default `Asc` keyword is applied when missing after the `property`.

An example of repository method with ordering:

[source,java]
----
include::{sourcedir}/includes/data/PetRepositorySnippets.java[tag=qbmn_sort_method, indent=0]
----
// end::data_repository_interface[]

// tag::data_pagination[]
== Pagination

Pagination allows user to split returned data collection into individual pages. When pagination is used, the repository method
must have an argument of `PageRequest` type. Return type of the method is `Slice` or `Page`.
The `PageRequest` argument of the method defines size of the page and index of the page (starting from `0`) to be returned.

Returned page content types:

[cols=2*]
|===
|Name |Description

|Slice
|Contains page data as `List` or `Stream` and `PageRequest` to return this page.

|Page
|Contains page data as `List` or `Stream`, total size of the result across all pages and `PageRequest` to return this page.
|===

An example of repository method with pagination:

[source,java]
----
include::{sourcedir}/includes/data/PetRepositorySnippets.java[tag=qbmn_slice_method, indent=0]
----
// end::data_pagination[]

// tag::data_dynamic_ordering[]
== Dynamic Ordering

Ordering part of the method name defines static ordering rule which cannot be modified at runtime. Dynamic ordering allows user
to define additional ordering rule which is defined at runtime. Dynamic ordering is triggered by adding an argument of `Sort`
type to the repository method. Both rules can be used simultaneously.

An example of repository method with dynamic ordering:

[source,java]
----
include::{sourcedir}/includes/data/PetRepositorySnippets.java[tag=qbmn_dynamic_sort_method, indent=0]
----

Static ordering rules from the method name are always applied first and dynamic rules are added after them.

[source,java]
----
include::{sourcedir}/includes/data/PetRepositorySnippets.java[tag=qbmn_dual_sort_method, indent=0]
----
// end::data_dynamic_ordering[]

// tag::data_session_access_1[]
== Persistence Session Access

User can get access to persistence provider session to implement more complex tasks which are not supported by this framework.
This feature is available to the data repository interface which extends `Data.SessionRepository<S>` interface. Generic argument
`S` is the persistence session type, e.g. `EntityManager`.

`Data.SessionRepository<S>` interface contains methods to provide session managed by data repository framework so there is no need
to handle session instance life-cycle.

[source,java]
----
include::{sourcedir}/includes/data/SimpleSnippets.java[tag=session_repository, indent=0]
----

Now EntityManager instance is available through Data.SessionRepository<EntityManager> interface methods:
// end::data_session_access_1[]

// tag::data_session_access_2[]
NOTE: `EntityManager` instance is valid only while `call` method is being executed. This instance must not be stored and used after
this method has ended.
// end::data_session_access_2[]