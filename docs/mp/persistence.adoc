///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2022 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Persistence
:description: Persistence-related support in Helidon MP
:keywords: datasource, helidon, jpa, jta, microprofile, mp
:rootdir: {docdir}/..

include::{rootdir}/includes/mp.adoc[]

== Contents

* <<Overview, Overview>>
* <<DS, Named Data Source Integration>>
** <<DS-Setup, Project Setup>>
*** <<DS-CP-Project-Setup, Setting Up a Connection Pool>>
**** <<DS-HikariCP-Project-Setup, Setting Up the Hikari CP Connection Pool>>
**** <<DS-UCP-Project-Setup, Setting Up the Oracle Universal Connection Pool>>
*** <<DS-Driver-Project-Setup, Setting Up a Database Driver>>
**** <<DS-H2-Driver-Project-Setup, Setting Up H2>>
**** <<DS-Oracle-Driver-Project-Setup, Setting Up Oracle JDBC>>
** <<DS-Configuration, Configuration>>
*** <<DS-Configuration-Examples, Examples>>
** <<DS-Usage, Usage>>
* <<JTA, Jakarta Transactions (JTA) Integration>>
** <<JTA-Maven-Coordinates,Maven Coordinates>>
** <<JTA-Configuration,Configuration>>
** <<JTA-Usage,Usage>>
* <<JPA, Jakarta Persistence (JPA) Integration>>

== Overview [[Overview]]

Helidon MP comes with deep integration for three broad,
specification-defined, persistence-related technologies that can be
used together or separately:

* Named https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/javax/sql/DataSource.html[data sources]
* https://jakarta.ee/specifications/transactions/2.0/[Jakarta Transactions] (JTA)
* https://jakarta.ee/specifications/persistence/3.0/[Jakarta Persistence] (JPA)

The integrations supported for each technology, their setup, their
configuration, and their usage are described below.

== Named Data Source Integration [[DS]]

=== Overview

Helidon MP's named data source integration allows you to safely inject
managed
https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/javax/sql/DataSource.html[`javax.sql.DataSource`]
instances that are annotated with
https://jakarta.ee/specifications/dependency-injection/2.0/apidocs/jakarta/inject/named[`jakarta.inject.Named`
annotations] into your Helidon MP application.
https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/java/sql/Connection.html[`java.sql.Connection`
objects]
https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/javax/sql/DataSource.html#getConnection()[acquired]
from these data sources will be pooled by one of two possible
connection pool implementations:

1. https://github.com/brettwooldridge/HikariCP[HikariCP]

2. https://docs.oracle.com/en/database/oracle/oracle-database/21/jjucp/index.html[Oracle
   Universal Connection Pool]

The connections managed by the connection pool will be supplied by
your relational database vendor's JDBC driver.

How you set up Helidon MP's named data source integration differs
depending on which of these two connection pools, which JDBC driver,
and which relational database product you use.  Example setups are
described below.

=== Project Setup [[DS-Setup]]

==== Setting Up a Connection Pool [[DS-CP-Project-Setup]]

===== Overview

Helidon MP's named data source integration requires a connection pool.
Helidon MP comes with support for two connection pools:

1. https://github.com/brettwooldridge/HikariCP[HikariCP]

2. https://docs.oracle.com/en/database/oracle/oracle-database/21/jjucp/index.html[Oracle
   Universal Connection Pool]

You can choose to use either, but not both.  Details concerning each
connection pool's setup are described below.

===== Setting Up the HikariCP Connection Pool [[DS-HikariCP-Project-Setup]]

====== Maven Coordinates (HikariCP) [[DS-HikariCP-Maven-Coordinates]]

To include the HikariCP connection pool in your Helidon MP
application, xref:../about/managing-dependencies.adoc[ensure your
dependencies are managed], and then ensure the following
`<dependency>` element is present as a child element of your project's
`pom.xml` file's `<dependencies>` element:

[source,xml]
----
<dependency>
    <groupId>io.helidon.integrations.cdi</groupId>
    <artifactId>helidon-integrations-cdi-datasource-hikaricp</artifactId>
    <scope>runtime</scope> <!--1-->
</dependency>
----
<1> Thehe `scope` is `runtime`, indicating that the HikariCP
    integration will be available on the runtime classpath.

===== Setting up the Oracle Universal Connection Pool [[DS-UCP-Project-Setup]]

====== Maven Coordinates (Oracle Universal Connection Pool) [[DS-UCP-Maven-Coordinates]]

To include the Oracle Universal Connection Pool in your Helidon MP
application, xref:../about/managing-dependencies.adoc[ensure your
dependencies are managed], and then ensure the following
`<dependency>` element is present as a child element of your project's
`pom.xml` file's `<dependencies>` element:

[source,xml]
----
<dependency>
  <groupId>io.helidon.integrations.cdi</groupId>
  <artifactId>helidon-integrations-cdi-datasource-ucp</artifactId>
  <scope>runtime</scope> <!--1-->
</dependency>
----
<1> The `scope` is `runtime`, indicating that the Oracle
    Universal Connection Pool integration will be available on the
    runtime classpath.

==== Setting Up a Database Driver [[DS-Driver-Project-Setup]]

===== Overview

Regardless of which connection pool you use, at the lowest level JDBC
database driver classes are responsible for making any connections to
a relational database.  JDBC database driver classes are
database-product-specific.

Once you have decided upon a relational database product to use, and
JDBC driver classes to use to connect to it,
xref:../about/managing-dependencies.adoc[ensure your dependencies are
managed], and then ensure that a `runtime`-scoped `<dependency>`
element describing your JDBC driver classes is present as a child
element of your project's `pom.xml` file's `<dependencies>` element.

A couple of examples are described below for some common database
products.  They are not exhaustive.

See the
https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/java/sql/package-summary.html[JDBC
4.3 Specification] for more information about JDBC.

===== Setting Up H2 [[DS-H2-Driver-Project-Setup]]

====== Maven Coordinates (H2) [[DS-H2-Driver-Maven-Coordinates]]

To include the http://www.h2database.com/html/main.html[H2 JDBC
driver] classes in your Helidon MP application so your application can
connect to an H2 database (whether in-memory or persistent):

* xref:../about/managing-dependencies.adoc[Ensure your dependencies are
managed]

Ensure the following
`<dependency>` element is present as a child element of your project's
`pom.xml` file's `<dependencies>` element:

[source,xml]
----
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <!--
         It's best to manage this with Maven's <dependencyManagement> feature,
         which is why the <version> element is commented out below.
         If nevertheless you opt for the explicit version here, check
         https://search.maven.org/search?q=g:com.h2database%20a:h2
         for up-to-date available versions.
    -->
    <!-- <version>2.1.212</version> -->
    <scope>runtime</scope> <!--1-->
</dependency>
----
<1> The `scope` is `runtime`, indicating that the H2
    JDBC driver classes will be available on the runtime classpath.

===== Setting Up Oracle JDBC [[DS-Oracle-Driver-Project-Setup]]

====== Maven Coordinates (Oracle JDBC) [[DS-Oracle-Driver-Maven-Coordinates]]

To include the Oracle JDBC driver classes in your Helidon MP
application so your application can connect to an Oracle database:

* xref:../about/managing-dependencies.adoc[Ensure your dependencies are
managed]

* Read and understand
  https://www.oracle.com/database/technologies/maven-central-guide.html[Developer's
  Guide For Oracle JDBC 21c on Maven Central]

Ensure the following
`<dependency>` element is present as a child element of your project's
`pom.xml` file's `<dependencies>` element:

[source,xml]
----
<dependency>
    <!--
         See
         https://www.oracle.com/database/technologies/maven-central-guide.html
         for more details.
     -->
    <groupId>com.oracle.database.jdbc</groupId>
    <!--
         Why ojdbc*11*? Because:
         (a) Helidon 3 targets Java 17
         (b) Java 17 includes JDBC 4.3
         (c) ojdbc11 implements relevant parts of JDBC 4.3
         Please see
         https://www.oracle.com/database/technologies/maven-central-guide.html
         for more details.
    -->
    <artifactId>ojdbc11</artifactId>
    <!--
         It's best to manage this with Maven's <dependencyManagement> feature,
         which is why the <version> element is commented out below.
         If nevertheless you opt for the explicit version here, check
         https://search.maven.org/search?q=g:com.oracle.database.jdbc
         for up-to-date available versions, and see
         https://www.oracle.com/database/technologies/maven-central-guide.html
         for extremely important information.
    -->
    <!-- <version>21.3.0.0</version> -->
    <scope>runtime</scope> <!--1-->
</dependency>
----
<1> The `scope` is `runtime`, indicating that the Oracle
    JDBC driver classes will be available on the runtime classpath.

=== Configuration [[DS-Configuration]]

==== Overview

Each connection pool supported by Helidon's named data source
integration support is, itself, a `DataSource` that wraps a
vendor-supplied `DataSource` present in the JDBC driver classes you
added to your project.  You must configure both the pool and the
vendor supplied `DataSource`.

To configure Helidon MP's named data source integration:

1. Decide where the configuration will reside, as permitted by
   xref:config/introduction.adoc[Helidon MP's MicroProfile Config
   implementation]

2. Create configuration suitable for the combination of your selected
   connection pool and your selected vendor-supplied `DataSource`
   implementation in that location.

Helidon MP's named data source integration relies on
xref:config/introduction.adoc[Helidon MP's usage of MicroProfile
Config], so you have many choices when deciding on your
configuration's location in (1) above.

The configuration values themselves are necessarily specific to the
connection pool you selected, and the vendor-supplied `DataSource`
responsible for actually connecting to your relational database.  In
general, at a minimum, you typically supply:

* information so the connection pool knows which vendor-supplied
  `DataSource` implementation to manage

* a JDBC URL describing where the database is located, so the managed
  vendor-supplied `DataSource` knows how to connect to it

* information required for the vendor-supplied `DataSource` to
  authenticate to the database

Some examples for common combinations follow.  They are not
exhaustive.

==== Configuration Prefixes

All MicroProfile Config-compatible property names for Helidon MP's
named data source integration follow a common pattern:

> _objecttype_._datasourcename_._propertyname_

* The name of a given configuration property always begins with the
  _objecttype_ portion: a fully-qualified Java class name of the
  object being configured.  Most configuration for Helidon MP's named
  data source integration concerns the behavior of
  `javax.sql.DataSource` objects, so most configuration property names
  begin with `javax.sql.DataSource`.

* A period (`.`) separates the _objecttype_ portion from the rest of
  the property name.

* The _datasourcename_ portion, the name of the data source being
  configured, comes next.  It cannot contain a period (`.`).

* A period (`.`) separates the _datasourcename_ portion from the rest
  of the property name.

* The _propertyname_ portion comes next, identifying the
  connection-pool- or vendor-supplied-`DataSource`-specific
  configuration property name, comes last.

As an example, configuration to set an imaginary `foo` property on the
`test` data source to `bar` looks like this in Java
`.properties`-style format:

[source,properties]
----
javax.sql.DataSource.test.foo=bar
----

==== Examples [[DS-Configuration-Examples]]

Here are some examples illustrating general configuration patterns in
various common MicroProfile Config-compatible locations.

===== Example: `META-INF/microprofile-config.properties` Classpath Resource

Here is an example of some data source configuration as might be found
in a `src/main/resources/META-INF/microprofile-config.properties`
configuration source:

[source,properties]
----
javax.sql.DataSource.yourDataSourceName.somePropertyOfYourConnectionPoolAndDataSource = itsValue
javax.sql.DataSource.yourDataSourceName.someOtherPropertyOfYourConnectionPoolAndDataSource = anotherValue
----

===== Example: System Properties Set on the Command Line

Here is an example using system properties on the command line instead:

[source,shell]
----
java \
  -Djavax.sql.DataSource.yourDataSourceName.somePropertyOfYourConnectionPoolAndDataSource=itsValue \
  -Djavax.sql.DataSource.yourDataSourceName.someOtherPropertyOfYourConnectionPoolAndDataSource=anotherValue \
  # ...
----

===== Example: Environment Variables Set on the Command Line

Here is an example using environment variables as typed directly into
a command line shell, taking advantage of MicroProfile Config's
mapping rules, since many shells will not understand environment
variable names with periods (.) in them:

[source,shell]
----
JAVAX_SQL_DATASOURCE_YOURDATASOURCENAME_SOMEPROPERTYOFYOURCONNECTIONPOOLANDDATASOURCE=itsValue \
JAVAX_SQL_DATASOURCE_YOURDATASOURCENAME_SOMEOTHERPROPERTYOFYOURCONNECTIONPOOLANDDATASOURCE=anotherValue \
java # ...
----

===== Example: Environment Variables Set By the `env` Command

Here is an example using environment variables as supplied via the
`env` shell command, thus removing the need for MicroProfile Config's
mapping rules:

[source,shell]
----
env 'javax.sql.DataSource.yourDataSourceName.somePropertyOfYourConnectionPoolAndDataSource=itsValue' \
  'javax.sql.DataSource.yourDataSourceName.someOtherPropertyOfYourConnectionPoolAndDataSource=anotherValue' \
  java # ...
----

===== Example: `application.yaml` Classpath Resource

Here is an example of some data source configuration as might be found
in a `src/main/resources/application.yaml` classpath resource:

[source,yaml]
----
javax:
  sql:
    DataSource:
      yourDataSourceName:
        somePropertyOfYourConnectionPoolAndDataSource: itsValue
        someOtherPropertyOfYourConnectionPoolAndDataSource: anotherValue
----

===== Example: Configuring the Oracle Universal Connection Pool and Oracle JDBC [[DS-Configuration-UCP-Oracle-Example]]

This example presumes you have:

* <<DS-UCP-Project-Setup,set up the Oracle Universal Connection Pool>>

* <<DS-Oracle-Driver-Project-Setup,set up Oracle JDBC>>

This example, in Java properties file format, configures an Oracle
Universal Connection Pool-managed data source named `main` to connect
to an Oracle Database on `localhost` port `1521`, using the
`oracle.jdbc.poolOracleDataSource` vendor-supplied `DataSource`, with
a service name of `XE`, a `user` of `scott`, and a `password` of
`tiger`:

[source,properties]
----
# (Why "connectionFactoryClassName"? See
# https://docs.oracle.com/en/database/oracle/oracle-database/21/jjuar/oracle/ucp/jdbc/PoolDataSourceImpl.html#setConnectionFactoryClassName_java_lang_String_)
javax.sql.DataSource.main.connectionFactoryClassName = oracle.jdbc.pool.OracleDataSource
javax.sql.DataSource.main.url = jdbc:oracle:thin://@localhost:1521/XE # see https://docs.oracle.com/en/database/oracle/oracle-database/21/jjdbc/data-sources-and-URLs.html#GUID-EF07727C-50AB-4DCE-8EDC-57F0927FF61A
javax.sql.DataSource.main.user = scott
javax.sql.DataSource.main.password = tiger
----

In general, the properties that can be set on the Oracle Universal
Connection Pool can be inferred from the "setter" methods found in
https://docs.oracle.com/en/database/oracle/oracle-database/21/jjuar/oracle/ucp/jdbc/PoolDataSourceImpl.html[the
javadoc for the `PoolDataSourceImpl` class].

In general, the properties that can be set on the
`oracle.jdbc.pool.OracleDataSource` `DataSource` implementation can be
inferred from the "setter" methods found in
https://docs.oracle.com/en/database/oracle/oracle-database/21/jajdb/oracle/jdbc/pool/OracleDataSource.html[its
javadoc].

NOTE: The Oracle Universal Connection Pool does not distinguish
cleanly between configuration properties that affect _its_ behavior
and those that affect the behavior of the vendor-supplied `DataSource`
implementation whose connections it pools, so in the example above it
is not possible to tell that `connectionFactoryClassName` is a
property of the Oracle Universal Connection Pool, and `user` is a
property of the `oracle.jdbc.pool.OracleDataSource` `DataSource`
implementation.  In some cases, the Oracle Universal Connection Pool
will set the given property on _both_ the connection pool itself _and_
on the vendor-supplied `DataSource` it manages.

===== Example: Configuring the HikariCP Connection Pool and H2 [[DS-Configuration-HikariCP-H2-Example]]

This example presumes you have:

* <<DS-HikariCP-Project-Setup,set up the HikariCP connection pool>>

* <<DS-H2-Driver-Project-Setup,set up H2>>

This example, in Java properties file format, configures a
HikariCP-managed data source named `test` to connect to an in-memory
H2 database named `unit-testing` with a `user` of `sa` and an empty
password:

[source,properties]
----
# Why "dataSourceClassName"? See
# https://github.com/brettwooldridge/HikariCP#essentials
javax.sql.DataSource.test.dataSourceClassName = org.h2.jdbcx.JdbcDataSource
# Why "dataSource."? See
# https://github.com/brettwooldridge/HikariCP/blob/HikariCP-5.0.1/src/main/java/com/zaxxer/hikari/util/PropertyElf.java#L47-L49
javax.sql.DataSource.test.dataSource.url = jdbc:h2:mem:unit-testing;DB_CLOSE_DELAY=-1 # see http://www.h2database.com/html/features.html#database_url
javax.sql.DataSource.test.dataSource.user = sa
javax.sql.DataSource.test.dataSource.password =
----

HikariCP's configuration properties are described
https://github.com/brettwooldridge/HikariCP#gear-configuration-knobs-baby[on
its Github repository].  Properties that should be forwarded on to the
vendor-supplied `DataSource` are prefixed with `dataSource.` as seen
in the example above.

In general, the properties that can be set on the
`org.h2.jdbcx.JdbcDataSource` vendor-supplied `DataSource` can be
inferred from the "setter" methods found in
http://www.h2database.com/javadoc/org/h2/jdbcx/JdbcDataSource.html[its
javadoc].

==== Usage [[DS-Usage]]

You use Helidon MP's named data source integration in the same way,
regardless of your choices of vendor-supplied `DataSource` and
connection pool.

To use Helidon MP's named data source integration in your application,
once it has been <<DS-Project-Setup,set up>> and
<<DS-Configuration,configured>>, create an ordinary
https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/javax/sql/DataSource.html[`DataSource`]-typed
injection point in a Java class representing a CDI bean somewhere in
your application,
https://jakarta.ee/specifications/dependency-injection/2.0/apidocs/jakarta/inject/named[annotated
with the name] of the data source you wish to use.

Here is how to define such a field-backed injection point:

[source,java]
----
import javax.sql.DataSource;

import jakarta.inject.Inject;
import jakarta.inject.Named;

// ...

@Inject // <1>
@Named("test") // <2>
private DataSource ds; // <3>
----
<1> https://jakarta.ee/specifications/dependency-injection/2.0/apidocs/jakarta/inject/inject[`@Inject`]
    marks the field as an injection point.  Its behavior is defined by
    the
    https://jakarta.ee/specifications/dependency-injection/2.0/[Jakarta
    Dependency Injection specification].
<2> https://jakarta.ee/specifications/dependency-injection/2.0/apidocs/jakarta/inject/named[`@Named("test")`]
    says to use the data source named `test`.
<3> The field injection point has a type of
    https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/javax/sql/DataSource.html[`javax.sql.DataSource`],
    and may be named anything you like.

Here is how to define such a constructor parameter injection point:

[source,java]
----
import javax.sql.DataSource;

import jakarta.inject.Inject;
import jakarta.inject.Named;

// ...

private final DataSource ds; // <1>

@Inject // <2>
public SomeObject(@Named("test") DataSource ds) { // <3>
    this.ds = ds; // <4>
}
----
<1> This is the field whose value will be set in the constructor.
<2> https://jakarta.ee/specifications/dependency-injection/2.0/apidocs/jakarta/inject/inject[`@Inject`]
    marks the constructor as one containing parameter injection
    points.  Its behavior is defined by the
    https://jakarta.ee/specifications/dependency-injection/2.0/[Jakarta
    Dependency Injection specification].
<3> https://jakarta.ee/specifications/dependency-injection/2.0/apidocs/jakarta/inject/named[`@Named("test")`]
    says to use the data source named `test`.  The parameter injection
    point has a type of
    https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/javax/sql/DataSource.html[`javax.sql.DataSource`],
    and may be named anything you like.
<4> The injected argument will never be `null`.

== Jakarta Transactions (JTA) Integration [[JTA]]

=== Overview

Helidon MP's Jakarta Transactions integration integrates the
https://www.narayana.io/[Naryana transaction engine], an
implementation of the
https://jakarta.ee/specifications/transactions/2.0/[Jakarta
Transactions Specification], into Helidon MP.  It lets you use
https://jakarta.ee/specifications/transactions/2.0/apidocs/jakarta/transaction/transactional[`@jakarta.transaction.Transactional`]
to declare JTA transactions in your Java code.

=== Maven Coordinates (JTA) [[JTA-Maven-Coordinates]]

To include Helidon's JTA integration in your application:

* xref:../about/managing-dependencies.adoc[Ensure your dependencies are
managed]

Ensure the following `<dependency>` elements are present as child
elements of your project's `pom.xml` file's `<dependencies>` element:

[source,xml]
----
<dependency>
    <groupId>jakarta.transaction</groupId>
    <artifactId>jakarta.transaction-api</artifactId>
    <scope>provided</scope> <!--1-->
</dependency>
<dependency>
    <groupId>io.helidon.integrations.cdi</groupId>
    <artifactId>helidon-integrations-cdi-jta-weld</artifactId>
    <scope>runtime</scope> <!--2-->
</dependency>
----
<1> The `scope` is `provided`, which ensures that the JTA
    classes required for compilation are available at compile time.    
<2> The implementation of these API classes will be available at
    runtime.

=== Configuration [[JTA-Configuration]]

==== Overview

Helidon MP's Jakarta Transactions integration does not require
configuration, but configuration is possible.  Because configuration
is of the https://narayana.io/[underlying Narayana transaction
engine], any restrictions are those of the engine, not of Helidon
itself.

Narayana, unlike Helidon MP, does not use MicroProfile Config, so its
configuration options are less flexible.  Some common examples follow.

==== Configuring the Object Store Directory

Narayana features an object store directory which it uses to store
information about transaction outcomes.  To set its location, you may set
the `ObjectStoreEnvironmentBean.objectStoreDir` system property to the
full path of a writeable directory:

[source,shell]
----
java -DObjectStoreEnvironmentBean.objectStoreDir=/var/tmp # ...
----

See
https://www.narayana.io//docs/project/index.html#d0e4013[Specifying
the object store location] for more information.

==== Configuring the Default Transaction Manager Timeout

To configure Narayana's default transaction manager timeout, set the
`com.arjuna.ats.arjuna.coordinator.defaultTimeout` system property to
an integral value in seconds:

[source,shell]
----
java -Dcom.arjuna.ats.arjuna.coordinator.defaultTimeout=60 # ...
----

For more on configuring Narayana, see
https://www.narayana.io//docs/project/index.html#chap-JBossJTA_Installation_Guide-Test_Chapter[Setting
Properties] in the Naryana documentation.

=== Usage [[JTA-Usage]]

To use Helidon MP's Jakarta Transactions integration, annotate a
method with the https://jakarta.ee/specifications/transactions/2.0/apidocs/jakarta/transaction/transactional[`jakarta.transaction.Transactional`] annotation:

[source,java]
----
import jakarta.transaction.Transactional;

// ...

@Transactional // <1>
public String getGreeting(Integer id) {
  // Use a JTA-aware facility to do something transactional here. <2>
}
----
<1> The
    https://jakarta.ee/specifications/transactions/2.0/apidocs/jakarta/transaction/transactional[`@Transactional`
    annotation] indicates that this method should be invoked in the
    scope of a JTA transaction.  **The object on which the method is
    invoked must be one that Helidon MP's CDI container has created**,
    i.e. it must be managed.  (CDI beans are managed, as are Jakarta
    RESTful Web Services resource classes.)
<2> For
    https://jakarta.ee/specifications/transactions/2.0/apidocs/jakarta/transaction/transactional[`@Transactional`]
    to have any effect, whatever is used inside the method must be
    JTA-aware (such as a Jakarta Persistence construct like an
    `EntityManager`).

== Jakarta Persistence (JPA) [[JPA]]

=== Overview

Helidon MP's
https://jakarta.ee/specifications/persistence/3.0/[Jakarta
Persistence] integration allows you to interact with Jakarta
Persistence (JPA) objects as if your code were running in an
application server, handling automatic creation and management of
objects such as `EntityManager` and `EntityManagerFactory` instances.

Jakarta Persistence is a Jakarta EE specification that describes,
among other things, how its implementations:

1. Map Java objects to relational database tables

2. Manage such persistent Java objects

3. Interact with <<JTA, Jakarta Transactions>>

4. Interact with <<DS, named data sources>>

Jakarta Persistence may be used in an entirely application-managed
manner, which requires no integration at all.  This
application-managed mode places the burden of error handling, thread
safety, transaction management, and other concerns on the user.
**This documentation does _not_ cover application-managed mode JPA.**

Jakarta Persistence may instead be used in a fully container-managed
manner, which requires that a container, like Helidon MP, handle error
management, thread safety and transaction management on behalf of the
user.  **This documentation covers this container-managed mode of JPA
exclusively.**

Helidon MP's Jakarta Persistence integration comes with support for
two JPA implementations, known as _JPA providers_:

1. https://hibernate.org/orm/documentation/6.1/[Hibernate ORM]

2. https://www.eclipse.org/eclipselink/documentation/[Eclipselink]

In any given project, you use one or the other, but not both.

How you set up Helidon MP's Jakarta Persistence integration differs
depending on which of these JPA providers you choose to use.

Jakarta Persistence requires <<JTA, Jakarta Transactions>> and makes
use of <<DS, named data sources>>, so as you set up your project you
will need to understand:

* <<DS, Helidon MP's named data source integration>>

* <<JTA, Helidon MP's Jakarta Transactions integration>>

=== Project Setup [[JPA-Setup]]

==== Setting Up a JPA Provider

===== Overview

While the Jakarta Persistence specification standardizes many aspects
around programming and usage, it deliberately leaves many required
setup and configuration aspects up to the JPA provider.  You will need
to set up your project differently depending on which JPA provider you
choose.

To set up Helidon MP's Jakarta Persistence integration in your
application to work with your chosen JPA provider, you must:

1. <<DS, Set up and configure named data sources as appropriate>>

2. <<JTA, Set up and configure Helidon MP's Jakarta Transactions
   support>>

3. Include the proper Jakarta Persistence-related dependencies

4. Set up your project to generate and compile the
   https://jakarta.ee/specifications/persistence/3.0/jakarta-persistence-spec-3.0.html#a6933[static
   metamodel]

4. Set up your project for _static weaving_

Details and examples for each supported JPA provider are below.

===== Maven Coordinates (Common) [[JPA-Maven-Coordinates]]

To include the Jakarta Persistence APIs that you will need and to
include the core of Helidon's Jakarta Persistence integration:

* xref:../about/managing-dependencies.adoc[Ensure your dependencies
  are managed]

* <<DS, Ensure you have set up and configured named data sources as
  appropriate>>

* <<JTA, Ensure you have set up and configured Helidon MP's Jakarta
  Transactions support>>

Ensure the following '<dependency>' elements are present as child
elements of your project's `pom.xml` file's `<dependencies>` element:

[source,xml]
----
<dependency>
    <groupId>jakarta.persistence</groupId>
    <artifactId>jakarta.persistence-api</artifactId>
    <scope>provided</scope> <!--1-->
</dependency>
<dependency>
    <groupId>io.helidon.integrations.cdi</groupId>
    <artifactId>helidon-integrations-cdi-jpa</artifactId>
    <scope>runtime</scope> <!--2-->
</dependency>
----
<1> The `scope` is `provided`, which ensures that the JPA classes
    required for compilation are available at compile time.
<2> The `scope` is `runtime`, which ensures that Helidon's core,
    provider-independent Jakarta Persistence integration is available at
    runtime.

This `<dependency>` does not set up a JPA provider.  See below.

===== Setting Up Static Metamodel Generation [[JPA-MetaModel]]

To generate and compile the Jakarta Persistence static metamodel for
your application, regardless of whether you are using Hibernate ORM or
Eclipselink, make sure the `<plugin>` element in the following code
snippet is present as a child element of the
`<pluginManagement><plugins>` element sequence as shown below:

[source,xml]
----
<pluginManagement>
    <plugins>

        <!-- ... -->

        <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <executions>
                <execution>
                    <id>default-compile</id>
                    <configuration>
                        <annotationProcessorPaths>
                            <annotationProcessorPath>
                                <groupId>org.hibernate.orm</groupId>
                                <artifactId>hibernate-jpamodelgen</artifactId>
                                <!--
                                    Always check
                                    https://search.maven.org/artifact/org.hibernate.orm/hibernate-jpamodelgen
                                    for up to date versions and make
                                    sure the version used is that of
                                    Hibernate ORM itself.
                                -->
                                <version>6.1.1.Final</version>
                            </annotationProcessorPath>
                        </annotationProcessorPaths>
                    </configuration>
                </execution>
            </executions>
        </plugin>

        <!-- ... -->

    </plugins>
</pluginManagement>
----

For more on the Hibernate ORM `hibernate-jpamodelgen` annotation
processor, see
https://hibernate.org/orm/tooling/#hibernate-metamodel-generator[Hibernate
Metamodel Generator] in Hibernate ORM's documentation.  Note that many
aspects of this documentation are outdated.

===== Maven Coordinates (Hibernate ORM) [[JPA-Hibernate-Maven-Coordinates]]

To include Helidon's Jakarta Persistence-related integration for
Hibernate ORM:

* xref:../about/managing-dependencies.adoc[Ensure your dependencies are
managed]

* <<JPA-Maven-Coordinates,Ensure the basics of your JPA project are
  set up properly>>

Ensure the following `<dependency>` elements are present as child
elements of your project's `pom.xml` file's `<dependencies>` element:

[source,xml]
----
<dependency>
    <groupId>io.helidon.integrations.cdi</groupId>
    <artifactId>helidon-integrations-cdi-eclipselink</artifactId>
    <scope>runtime</scope> <!--1-->
</dependency>
----
<1> The `scope` is `runtime`, which ensures that Helidon MP's
    Hibernate ORM integration is available at runtime.

===== Setting Up Static Weaving (Hibernate ORM) [[JPA-Hibernate-Weaving]]

Hibernate ORM can alter your classes' bytecode at build time to keep
track of changes made to objects participating in Jakarta Persistence
workflows.

To set up this required static weaving for Hibernate ORM, ensure that
the following `<plugin>` element is present as a child element of your
project's `pom.xml` file's `<plugins>` element:

[source,xml]
----
<plugin>
    <groupId>org.hibernate.orm.tooling</groupId>
    <artifactId>hibernate-enhance-maven-plugin</artifactId>
    <!--
        Ideally, your plugin versions are managed via a
        <pluginManagement> element, which is why the <version> element
        is commented out below.  If, nevertheless, you opt for the
        explicit version, check
        https://search.maven.org/artifact/org.hibernate.orm/hibernate-enhance-maven-plugin
        for up-to-date versions, and make sure the version is the same
        as that of Hibernate ORM itself.
    -->
    <!-- <version>6.1.1.Final</version> -->
    <executions>
        <execution>
            <id>Statically enhance JPA entities for Hibernate</id>
            <phase>compile</phase>
            <goals>
                <goal>enhance</goal>
            </goals>
            <configuration>
                <failOnError>true</failOnError>
                <enableDirtyTracking>true</enableDirtyTracking>
                <enableLazyInitialization>true</enableLazyInitialization>
            </configuration>
        </execution>
    </executions>
</plugin>
----

Add a file named `src/main/resources/META-INF/hibernate.properties`
with the following line as its sole contents:

[source,properties]
----
hibernate.bytecode.provider=none
----

For more on the `hibernate-enhance-maven-plugin` in particular, see
https://docs.jboss.org/hibernate/orm/6.1/userguide/html_single/Hibernate_User_Guide.html#tooling-maven[its
documentation].

For more on Hibernate ORM's bytecode enhancement (weaving) in general,
see
https://docs.jboss.org/hibernate/orm/6.1/userguide/html_single/Hibernate_User_Guide.html#BytecodeEnhancement[Bytecode
Enhancement] in Hibernate ORM's documentation.

===== Maven Coordinates (Eclipselink) [[JPA-Eclipselink-Maven-Coordinates]]

To include Helidon's Jakarta Persistence-related integration for
Eclipselink:

* xref:../about/managing-dependencies.adoc[Ensure your dependencies are
managed]

* <<JPA-Maven-Coordinates,Ensure the basics of your JPA project are
  set up properly>>

Ensure the following `<dependency>` elements are present as child
elements of your project's `pom.xml` file's `<dependencies>` element:

[source,xml]
----
<dependency>
    <groupId>io.helidon.integrations.cdi</groupId>
    <artifactId>helidon-integrations-cdi-eclipselink</artifactId>
    <scope>runtime</scope> <!--1-->
</dependency>
----
<1> The `scope` is `runtime`, which ensures that Helidon MP's
    Eclipselink integration is available at runtime.

===== Setting Up Static Weaving (Eclipselink) [[JPA-Eclipselink-Weaving]]

Eclipselink can alter your classes' bytecode at build time to keep
track of changes made to objects participating in Jakarta Persistence
workflows.

To set up this required static weaving for Eclipselink, ensure that
the following `<plugin>` element is present as a child element of your
project's `pom.xml` file's `<plugins>` element:

[source,xml]
----
<plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>exec-maven-plugin</artifactId>
    <!--
        Ideally, your plugin versions are managed via a
        <pluginManagement> element, which is why the <version> element
        is commented out below.  If, nevertheless, you opt for the
        explicit version, check
        https://search.maven.org/artifact/org.codehaus.mojo/exec-maven-plugin
        for up-to-date versions.
    -->
    <!-- <version>3.1.0</version> -->
    <executions>
        <execution>
            <id>weave</id>
            <phase>process-classes</phase>
            <goals>
                <goal>java</goal>
            </goals>
            <configuration combine.self="override">
                <classpathScope>compile</classpathScope>
                <mainClass>org.eclipse.persistence.tools.weaving.jpa.StaticWeave</mainClass>
                <arguments>
                    <argument>-loglevel</argument>
                    <argument>INFO</argument>
                    <argument>-persistenceinfo</argument>
                    <argument>${project.build.outputDirectory}</argument>
                    <argument>${project.build.outputDirectory}</argument>
                    <argument>${project.build.outputDirectory}</argument>
                </arguments>
            </configuration>
        </execution>
    </executions>
</plugin>
----

For more on the Eclipselink static weaving command-line utility, see
https://wiki.eclipse.org/EclipseLink/UserGuide/JPA/Advanced_JPA_Development/Performance/Weaving/Static_Weaving#Use_the_Command_Line[Static
Weaving] in the Eclipselink documentation.

