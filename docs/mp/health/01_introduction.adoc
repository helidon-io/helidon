///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2020, 2022 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= MicroProfile Health
:spec-name: MicroProfile Health
:description: {spec-name} support in Helidon MP
:keywords: helidon, mp, microprofile, health
:h1Prefix: MP
:health-release: {version.lib.microprofile-health}
:feature-name: MicroProfile Health
:common-deps-page-prefix-inc: ../../shared/dependencies/common_shared.adoc
:microprofile-bundle: true

== ToC

- Overview
- Maven
- Usage
- API
- Configuration
- Reference
- Examples
- Other

== Overview
Microservices expose their health status primarily so external tools (for example, an orchestrator such as Kubernetes)
can monitor each service and take action, such as restarting a service instance if it has failed
or temporarily shunting traffic away from the instance if the service is unable to process
incoming requests normally.

include::{common-deps-page-prefix-inc}[tag=maven-dependency]

[source,xml]
----
<dependency>
    <groupId>io.helidon.microprofile.health</groupId>
    <artifactId>helidon-microprofile-health</artifactId>
</dependency>
----

To enable built-in health checks add the following dependency
(or use the <<mp/introduction/02_microprofile.adoc, helidon-microprofile bundle>> )

[source,xml]
----
<dependency>
    <groupId>io.helidon.health</groupId>
    <artifactId>helidon-health-checks</artifactId>
</dependency>
----


== Usage

Helidon Health implements MicroProfile Health Checks
link:http://download.eclipse.org/microprofile/microprofile-health-{health-release}/microprofile-health-spec.html[Specification].
The spec prescribes how external tools probe a service's health checks and how you
implement health checks as part of your microservice that are specific to your service's needs.

=== Concepts - Liveness, Readiness, and Startup Checks

MicroProfile Health supports three types of health checks:

_Liveness_ checks report whether the runtime environment in which the service is running
is sufficient to support the work the service performs.
The environment is beyond the control of
the service itself and typically cannot improve without outside intervention.
If a microservice instance reports a `DOWN`
liveness check, it should never report `UP` later.
It will need to be stopped and a replacement instance created.

_Readiness_ checks report whether the service is _currently_ capable of performing its work.
A service that reports `DOWN` for its readiness cannot _at the moment_ do its job, but at
some future point it might become able to do so without requiring a restart.

_Startup_ checks indicate whether the service has started to the point where liveness and readiness checks even make sense.
A service reporting `DOWN` for a startup check is still initializing itself and normally will report `UP`, assuming it has started successfully.

The following table describes more about these types of health checks, including how an orchestrator
such as Kubernetes might react.


== API
A MicroProfile-compliant service reports its health via known REST endpoints. Helidon MP
provides these endpoints automatically as part of every MP microservice.

External management tools (or `curl` or browsers) retrieve health checks using the REST endpoints in the following table which summarizes the types of health checks in MicroProfile Health.
Responses from the health endpoints report `200` (OK), `204` (no content), or `503` (service unavailable) depending on the outcome of running the health checks.
HTTP `GET` responses include JSON content showing the detailed results of all the health checks which the server executed after receiving the request.
HTTP `HEAD` requests return only the status with no payload.


.Types of Health Checks
|===
|Type | Meaning | REST endpoint | Kubernetes response on failure

|liveness
|whether the runtime environment is suitable
|`/health/live`
|Restarts container.

|readiness
|whether the microservice is currently capable of doing its work
|`/health/ready`
|Diverts requests away from the instance; periodically rechecks readiness and resumes traffic once the
microservice reports itself as ready.

|startup
|whether the microservice has initialized to the point where liveness and readiness checks might pass
|`/health/started`
|Treats the instance as still starting up; does not check liveness or readiness until the startup probe reports success or times out according to its configuration.
|===


== Configuration

=== Custom Health Root Path and Port

You can specify a custom port and root context for the root health endpoint path.
However, you cannot use different ports, such as http://localhost:8080/myhealth and http://localhost:8081/myhealth/live.
Likewise, you cannot use different paths, such as http://localhost:8080/health and http://localhost:8080/probe/live.

The example below will change the root path.

[source,yaml]
.Create a file named `application.yaml` in the `resources` directory with the following contents:
----
health:
  web-context: "myhealth"  // <1>
----
<1> The web-context specifies a new root path for the health endpoint.

[source,bash]
.Build and run the application, then verify that the health endpoint is using the new `/myhealth` root:
----
> curl http://localhost:8080/myhealth
> curl http://localhost:8080/myhealth/live
> curl http://localhost:8080/myhealth/ready
> curl http://localhost:8080/myhealth/started
----

== Reference

Configuration properties, values and description

|===
|Property | Values | Description

|health:web-context
|`String`
| The endpoint name on which the health context is propagated

|===


== Examples

Generate Helidon MP Quickstart project following these <<Instructions>>

=== Using the Built-In Health Checks

Helidon has a set of built-in health checks that are automatically enabled to report various
health check statuses that are commonly used:

* deadlock detection
* available disk space
* available heap memory

The following example will demonstrate how to use the built-in health checks.  These examples are all executed
from the root directory of your project (helidon-quickstart-mp).

[source,bash]
.Build the application, skipping unit tests, then run it:
----
mvn package
java -jar target/helidon-quickstart-mp.jar
----

[source,bash]
.Verify the health endpoint in a new terminal window:
----
> curl http://localhost:8080/health
----

[source,json]
.JSON response:
----
{
  "status": "UP",
  "checks": [
    {
      "name": "deadlock",
      "status": "UP"
    },
    {
      "name": "diskSpace",
      "status": "UP",
      "data": {
        "free": "325.54 GB",
        "freeBytes": 349543358464,
        "percentFree": "69.91%",
        "total": "465.63 GB",
        "totalBytes": 499963174912
      }
    },
    {
      "name": "heapMemory",
      "status": "UP",
      "data": {
        "free": "230.87 MB",
        "freeBytes": 242085696,
        "max": "3.56 GB",
        "maxBytes": 3817865216,
        "percentFree": "98.90%",
        "total": "271.00 MB",
        "totalBytes": 284164096
      }
    }
  ]
}
----

=== Custom Liveness Health Checks

You can create application-specific custom health checks and integrate them with Helidon
using CDI.  The following example shows how to add a custom liveness health check.

[source,java]
.Create a new `GreetLivenessCheck` class with the following content:
----
@Liveness // <1>
@ApplicationScoped // <2>
public class GreetLivenessCheck implements HealthCheck {
  private GreetingProvider provider;

  @Override
  public HealthCheckResponse call() {
    return HealthCheckResponse.named("LivenessCheck")  // <3>
        .up()
        .withData("time", System.currentTimeMillis())
        .build();
  }
}
----
<1> Annotation indicating this is a liveness health check.
<2> Annotation indicating there is a single liveness `HealthCheck` object during the lifetime of the application.
<3> Build the HealthCheckResponse with status `UP` and the current time.

[source,bash]
.Build and run the application, then verify the custom liveness health endpoint:
----
curl http://localhost:8080/health/live
----

[source,json]
.JSON response:
----
{
  "status": "UP",
  "checks": [
    {
      "name": "LivenessCheck",
      "status": "UP",
      "data": {
        "time": 1566338255331
      }
    }
  ]
}
----

Full example code is available <<here>>.


=== Custom Readiness Health Checks

You can add a readiness check to indicate that the application is ready to be used.  In this
example, the server will wait five seconds before it becomes ready.

[source,java]
.Create a new `GreetReadinessCheck` class with the following content:
----
@Readiness // <1>
@ApplicationScoped
public class GreetReadinessCheck implements HealthCheck {
  private final AtomicLong readyTime = new AtomicLong(0);

  @Override
  public HealthCheckResponse call() {
    return HealthCheckResponse.named("ReadinessCheck")  // <2>
        .status(isReady())
        .withData("time", readyTime.get())
        .build();
  }

  public void onStartUp(
      @Observes @Initialized(ApplicationScoped.class) Object init) {
    readyTime.set(System.currentTimeMillis()); // <3>
  }

  private boolean isReady() { // <4>
    return Duration.ofMillis(System.currentTimeMillis() - readyTime.get()).getSeconds() >= 5;
  }
}
----
<1> Annotation indicating that this is a readiness health check.
<2> Build the `HealthCheckResponse` with status `UP` after five seconds, else `DOWN`.
<3> Record the time at startup.
<4> Become ready after 5 seconds.

[source,bash]
.Build and run the application.  Issue the curl command with -v within five seconds and you will see that the application is not ready:
----
> curl -v  http://localhost:8080/health/ready
----

[source,json]
.HTTP response:
----
...
< HTTP/1.1 503 Service Unavailable // <1>
...
{
  "status": "DOWN",
  "checks": [
    {
      "name": "ReadinessCheck",
      "status": "DOWN",
      "data": {
        "time": 1566399775700
      }
    }
  ]
}
----
<1> The HTTP status is `503` since the application is not ready.

[source,bash]
.After five seconds you will see the application is ready:
----
> curl -v http://localhost:8080/health/ready
----

[source,json]
.JSON response:
----
...
< HTTP/1.1 200 OK // <1>
...
{
  "status": "UP",
  "checks": [
    {
      "name": "ReadinessCheck",
      "status": "UP",
      "data": {
        "time": 1566399775700
      }
    }
  ]
}
----
<1> The HTTP status is `200` indicating that the application is ready.

Full example code is available <<here>>.

=== Custom Startup Health Checks

You can add a startup check to indicate whether or not the application has initialized to the point that the other health checks make sense.
In this example, the server will wait eight seconds before it declares itself started.

[source,java]
.Create a new `GreetStartedCheck` class with the following content:
----
@Started // <1>
@ApplicationScoped
public class GreetStartedCheck implements HealthCheck {
  private final AtomicLong readyTime = new AtomicLong(0);


  @Override
  public HealthCheckResponse call() {
    return HealthCheckResponse.named("StartedCheck")  // <2>
        .status(isStarted())
        .withData("time", readyTime.get())
        .build();
  }

  public void onStartUp(
      @Observes @Initialized(ApplicationScoped.class) Object init) {
    readyTime.set(System.currentTimeMillis()); // <3>
  }

  private boolean isStarted() { // <4>
    return Duration.ofMillis(System.currentTimeMillis() - readyTime.get()).getSeconds() >= 8;
  }
}
----
<1> Annotation indicating that this is a startup health check.
<2> Build the `HealthCheckResponse` with status `UP` after eight seconds, else `DOWN`.
<3> Record the time at startup of Helidon; the application will declare itself as started eight seconds later.
<4> Become ready after 5 seconds.

[source,bash]
.Build and run the application.  Issue the curl command with -v within five seconds and you will see that the application has not yet started:
----
> curl -v  http://localhost:8080/health/started
----

[source,json]
.HTTP response:
----
...
< HTTP/1.1 503 Service Unavailable // <1>
...
{
  "status": "DOWN",
  "checks": [
    {
      "name": "StartedCheck",
      "status": "DOWN",
      "data": {
        "time": 1566399775700
      }
    }
  ]
}
----
<1> The HTTP status is `503` since the application has not started.

[source,bash]
.After eight seconds you will see the application has started:
----
> curl -v http://localhost:8080/health/started
----

[source,json]
.JSON response:
----
...
< HTTP/1.1 200 OK // <1>
...
{
  "status": "UP",
  "checks": [
    {
      "name": "StartedCheck",
      "status": "UP",
      "data": {
        "time": 1566399775700
      }
    }
  ]
}
----
<1> The HTTP status is `200` indicating that the application is started.

When using the health check URLs, you can get the following health check data:

* liveness only - http://localhost:8080/health/live
* readiness only -  http://localhost:8080/health/ready
* startup checks only - http://localhost:8080/health/started
* all health check data -  http://localhost:8080/health

[source,bash]
.Get all the health check data, including custom data:
----
> curl http://localhost:8080/health
----

[source,json]
.JSON response:
----
{
  "status": "UP",
  "checks": [
    {
      "name": "LivenessCheck",
      "status": "UP",
      "data": {
        "time": 1566403431536
      }
    },
    ...
}
----

Full example code is available <<here>>.

== Additional information

Some additional information if available

