== Custom configuration sources

To use custom configuration sources, your application needs to use a `Config` object when
creating a `Server` object.  When you use a `Config` object, you are in full control of
all configuration sources and precedence. By default, the environment variable and system property
sources are enabled, but you can disable them using the `disableEnvironmentVariablesSource` and `disableSystemPropertiesSource`
methods.

This section will show you how to use a custom configuration with various sources, formats, and precedence rules.

=== Full list of configuration sources

Here is the full list of external config sources that you can use programmatically.

1. Java system properties - the property is a name/value pair.
2. Environment variables - the property is a name/value pair.
3. Resources in the classpath - the contents of the resource is parsed according to its inferred format.
4. File - the contents of the file is parsed according to its inferred format.
5. Directory - each non-directory file in the directory becomes a config entry: the file name is the key.
and the contents of that file are used as the corresponding config String value.
6. A URL resource - contents is parsed according to its inferred format.

You can also define custom sources, such as Git, and use them in your Helidon application.
See <<config/06_advanced-configuration.adoc,Advanced Config>> for more information.

=== Classpath sources

The first custom resource example demonstrates how to add a second internal configuration resource that is discovered in the `classpath`.
The code needs to build a `Config` object, which in turn is used to build the `Server` object.  The `Config` object is built using a `Config.Builder`,
which lets you inject any number of sources into the builder.  Furthermore, you can set precedence for the sources.
The first source has highest precedence, then the next has second highest, and so forth.

[source,text]
.Add a resource file, named `config.properties` to the `resources` directory with the following contents:
----
app.greeting=HelloFrom-config.properties
----

[source,java]
.Update the `Main` class; 1) Add new imports, 2) Replace the `startServer` method, and 3) Add `buildConfig` method:
----
import io.helidon.config.Config; //<1>
import static io.helidon.config.ConfigSources.classpath;
...

  static Server startServer() {
        return Server.builder()
            .config(buildConfig()) // <2>
            .build()
            .start();
    }

  private static Config buildConfig() {
    return Config.builder()
        .disableEnvironmentVariablesSource() // <3>
        .sources(
            classpath("config.properties"), // <4>
            classpath("META-INF/microprofile-config.properties")) // <5>
        .build();
  }
----
<1> Import config classes.
<2> Pass the custom `Config` object to the `Server.Builder`.
<3> Disable the environment variables as a source.
<4> Specify the new config.properties resource that is in the `classpath`.
<5> You must specify the existing `META-INF/microprofile-config.properties` or Helidon will not use it as a configuration source
even though it is considered a default source.

[source,bash]
.Build and run the application (without the system property).  Invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFrom-config.properties World!" # <1>
}
----
<1> The greeting was picked up from `config.properties`, overriding the value in `META-INF/microprofile-config.properties`.

NOTE: It is important to remember that configuration from all sources is merged internally.  If you have the same
configuration property in multiple sources, then only the one with highest precedence will be used at runtime.
This is true even the same property comes from sources with different formats.

Swap the source order and run the test again.

[source,java]
.Update the `Main` class and replace the `buildConfig` method:
----
  private static Config buildConfig() {
      return Config.builder()
          .disableEnvironmentVariablesSource()
          .sources(
              classpath("META-INF/microprofile-config.properties"), // <1>
              classpath("config.properties"))
          .build();
  }
----
<1> Swap the source order, putting `META-INF/microprofile-config.properties` first.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromMPConfig World!" // <1>
}
----
<1> The file `META-INF/microprofile-config.properties` was used to get the greeting since it now has precedence over `config.properties`.

=== External file sources

You can move all or part of your configuration to external files, making them optional or mandatory.  The obvious advantage to this
approach is that you do not need to rebuild your application to change configuration.  In the following
example, the `app.greeting` configuration property will be added to `config-file.properties`.

[source,bash]
.Unset the environment variable so that `disableEnvironmentVariablesSource` doesn't need to be called:
----
unset APP_GREETING
----

[source,bash]
.Create a file named `config-file.properties` in the `helidon-quickstart-mp` directory with the following contents:
----
app.greeting=HelloFromConfigFile
----

[source,java]
.Update the `Main` class; 1) Add new import and 2) Replace the `buildConfig` method:
----
import static io.helidon.config.ConfigSources.file;
...

  private static Config buildConfig() {
      return Config.builder()
          .sources(
              file("config-file.properties"), // <1>
              classpath("META-INF/microprofile-config.properties"))
          .build();
  }
----
<1> Add a mandatory configuration file.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromConfigFile World!" # <1>
}
----
<1> The configuration property from the file `config-file.properties` takes precedence.

NOTE: If you want the configuration file to be optional, you must use the `optional` method with `sources`,
otherwise Helidon will generate an error during startup as shown below.  This is true for both `file` and
`classpath` sources.  By default, these sources are mandatory.

[source,java]
.Update the `Main` class and replace the `buildConfig` method:
----
  private static Config buildConfig() {
      return Config.builder()
          .sources(
              file("missing-file"), // <1>
              classpath("META-INF/microprofile-config.properties"))
          .build();
  }
----
<1> Specify a file that doesn't exist.

[source,bash]
.Build then start the application and you will see the following output:
----
Exception in thread "main" io.helidon.config.ConfigException: Cannot load data from mandatory source FileConfig[missing-file]. File `missing-file` not found.
----

To fix this, use the `optional` method as shown below, then rerun the test.

----
...
    file("missing-file").optional(), // <1>

----
<1> The `missing-file` configuration file is now optional.

=== Directory source

A directory source treats every file in the directory as a key, and the file contents as the value.  The
following example includes a directory source as highest precedence.

[source,bash]
.Create a new directory `helidon-quickstart-mp/conf` then create a file named `app.greeting` in that directory with the following contents:
----
HelloFromFileInDirectoryConf
----

[source,java]
.Update the `Main` class; 1) Add new import and 2) Replace the `buildConfig` method:
----
import static io.helidon.config.ConfigSources.directory;
...

  private static Config buildConfig() {
      return Config.builder()
          .sources(
              directory("conf"), // <1>
              classpath("config.properties").optional(),
              classpath("META-INF/microprofile-config.properties"))
          .build();
  }
----
<1> Add a mandatory configuration directory.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromFileInDirectoryConf World!" # <1>
}
----
<1> The greeting was fetched from the file named `app.greeting`.

==== Exceeding three sources

If you have more than three sources, you need to use a `ConfigSources` class to create a
custom source list as shown below.

[source,java]
.Update the `Main` class; 1) Add new import and 2) Replace the `buildConfig` method:
----
import io.helidon.config.ConfigSources;
...

  private static Config buildConfig() {
      return Config.builder()
          .sources(ConfigSources.create(   // <1>
              directory("conf"),
              file("config-file.properties"),
              classpath("config.properties").optional(),
              classpath("META-INF/microprofile-config.properties")))
          .build();
  }
----
<1> Create a list of four sources using `ConfigSources.create` method.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...

{
  "message": "HelloFromFileInDirectoryConf World!"
}
----

=== Meta-configuration

Instead of directly specifying the configuration sources in your code, you can use meta-configuration in a file that declares
the configuration sources and their attributes. This requires using the `Config.loadSourcesFrom` method rather than a `Config.Buider`
object. The contents of the meta-configuration file needs to be in JSON, YAML, or HOCON format. YAML is used in the following example.

[source,bash]
.Create a file named `meta-config.yaml` in the `helidon-quickstart-mp` directory with the following contents:
----
sources:
  - type: "classpath" // <1>
    properties:
      resource: "META-INF/microprofile-config.properties" // <2>
----
<1> The source type.
<2> The name of the mandatory configuration resource.


[source,java]
.Update the `Main` class and replace the `buildConfig` method:
----
  private static Config buildConfig() {
      return Config.loadSourcesFrom( file("meta-config.yaml")); // <1>
  }
----
<1> Specify the meta-configuration file, which contains a single configuration source.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromMPConfig World!" // <1>
}
----
<1> The `META-INF/microprofile-config.properties` resource file was used to get the greeting.

The source precedence order in a meta-configuration file is the order of appearance in the file.
This is demonstrated below where the `config-file.properties` has highest precedence.

[source,bash]
.Replace the contents of the `meta-config.yaml` file:
----
sources:
  - type: "file" // <1>
    properties:
      path: "./config-file.properties" // <2>
  - type: "classpath"
    properties:
      resource: "META-INF/microprofile-config.properties"
  - type: "file"
    properties:
      path: "optional-config-file"
      optional: true  // <3>
----
<1> The source type specifies a file.
<2> The name of the mandatory configuration file.
<3> Specify that the `optional-config-file` file is optional.

[source,bash]
.Restart the application, then invoke the endpoint below and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromConfigFile World!" // <1>
}
----
<1> The `config-file.properties` source now takes precedence.

When using a meta-config file, you need to explicitly include both environment variables and system properties as
a source if you want to use them.

[source,bash]
.Replace the contents of the `meta-config.yaml` file:
----
sources:
  - type: "environment-variables" // <1>
  - type: "system-properties" // <2>
  - type: "classpath"
    properties:
      resource: "META-INF/microprofile-config.properties"
  - type: "file"
    properties:
      path: "./config-file.properties"
----
<1> Environment variables are now used as a source.
<2> System properties are now used as a source.


You can re-run the previous tests that exercised environment variables and system properties.  Swap the two types to see
the precedence change.  Be sure to unset APP_GREETING after you finish testing.
