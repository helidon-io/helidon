///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019, 2020 Oracle and/or its affiliates.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= MicroProfile GraphQL
:h1Prefix: MP
:pagename: microprofile-graphql
:description: Helidon GraphQL MicroProfile
:keywords: helidon, graphql, microprofile, micro-profile


The Microprofile GraphQL APIs are an extension to <<microprofile/01_introduction.adoc, Helidon MP>>
to allow building of applications that can expose a GraphQL endpoint and optionally a link:https://github.com/graphql/graphiql[GraphiQL] API.

== About the MicroProfile GraphQL Specification
Helidon MP implements the MicroProfile GraphQL
link:https://github.com/eclipse/microprofile-graphql[spec] version 1.0.3.
The spec prescribes how applications can be built to expose an endpoint for GraphQL.
GraphQL is an open-source data query and manipulation language for APIs,
and a runtime for fulfilling queries with existing data.
It provides an alternative, though not necessarily a replacement for REST.

For more information on GraphQL see https://graphql.org/.

== Maven Coordinates

The <<about/04_managing-dependencies.adoc, Managing Dependencies>> page describes how you
should declare dependency management for Helidon applications. Then declare the following dependency in your project:

[source,xml]
----
<dependency>
    <groupId>io.helidon.microprofile.graphql</groupId>
    <artifactId>helidon-microprofile-graphql-server</artifactId>
</dependency>
----

== Getting Started

=== Defining your API

The MicroProfile GraphQL specification defines a number of key annotations to be used when writing a GraphQL endpoint:

* `@GraphQLApi` - identifies a CDI Bean as a GraphQL Endpoint
* `@Query` - identifies a method as returning specified fields for an object or collection of entities
* `@Mutation` - identifies a method which creates, deletes or updates entities

NOTE: Please see the link:https://github.com/eclipse/microprofile-graphql[Microprofile GraphQL spec] for the full list of available annotations.

For example, the following defines a GraphQL endpoint with a number of queries and mutations that work
against a fictional `CustomerService` service and `Customer` class.

[source,java]
.Simple ContactGraphQLApi
----
@ApplicationScoped
@org.eclipse.microprofile.graphql.GraphQLApi
public class ContactGraphQLApi {

    @Inject
    private CustomerService customerService;

    @org.eclipse.microprofile.graphql.Query
    public Collection<Customer> findAllCustomers() {  <1>
        return customerService.getAllCustomers();
    }

    @org.eclipse.microprofile.graphql.Query
    public Customer findCustomer(@Name("customerId") int id) {  <2>
        return customerService.getCustomer(id);
    }

    @org.eclipse.microprofile.graphql.Query
    public Collection<Customer> findCustomersByName(@Name("name") String name) {  <3>
        return customerService.getAllCustomers(names);
    }

    @org.eclipse.microprofile.graphql.Mutation
    public Contact createCustomer(@Name("customerId") int id,  <4>
                                  @Name("name") String name,
                                  @Name("balance") float balance) {
        return customerService.createCustomer(id, name, balance);
    }
}

public class customer {
    private int id;
    @NonNull
    private String name;
    private float balance;

    // getters and setters omitted for brevity
}
----

<1> a query with no-arguments that will return all Customers
<2> a query that takes an argument to return a specific Customer
<3> a query that optionally takes a name and returns a collection of Customers
<4> a mutation that creates a Customer and returns the newly created Customer

The above would generate a GraphQL schema as shown below:
[source,graphql]
.Sample GraphQL Schema
----
type Query {
   findAllCustomers: [Customer]
   findCustomer(customerId: Int!): Customer
   findCustomersByName(name: String): [Customers]
}

type Mutation {
   createCustomer(customerId: Int!, name: String!, balance: Float!): Customer
}

type Customer {
   id: Int!
   name: String!
   balance: Float
}
----

After application startup, a GraphQL schema will be generated from your annotated API classes
and POJO's and you will be able to access these via the URL's described below.

=== Creating your entry-point

As per the instructions <<mp/introduction/02_microprofile.adoc, here>> ensure you have added a
`src/main/resources/META-INF/beans.xml` file  so the CDI implementation can pick up your classes.

Add a main method or dedicated Main class to start everything up.

[source,java]
.Sample Entry-point
----
public class MyMain {
    public static void main(String[] args) {
        io.helidon.microprofile.server.Main.main(args);
    }
}
----

=== Building your application

As part of building your application, you must create a Jandex index
using the `jandex-maven-plugin` for all API and POJO classes that are used.

[source,xml]
.Generate Jandex index
----
<plugin>
<groupId>org.jboss.jandex</groupId>
<artifactId>jandex-maven-plugin</artifactId>
<version>1.0.8</version>
<executions>
  <execution>
    <id>make-index</id>
  </execution>
</executions>
</plugin>
----

== Accessing the GraphQL end-points

After starting your application you should see a message similar to the following
indicating the GraphQL application has be started:

[source,bash]
.Sample Startup output
----
[Mon. Nov. 02 14:54:11 AWST 2020] INFO: io.helidon.microprofile.server.ServerCdiExtension addApplication
     - Registering JAX-RS Application: GraphQLApplication
----

Once you access the built-in GraphiQL endpoint at `http://host:port/ui` or
using your GraphQL client via the `http://host:port/graphql` end-point a message indicating the
GraphQL Schema has been generated will be displayed as shown if your log level is set to `FINE`:

[source,bash]
.Sample Schema Message
----
[Mon. Nov. 02 14:54:16 AWST 2020] FINE: io.helidon.microprofile.graphql.server.ExecutionContext <init> - Generated schema:
... Schema displayed here
----

.GraphQL UI
image::mp/graphql_01_introduction_graphiql.png[GraphiQL]

== Configuration Options

TBC.


