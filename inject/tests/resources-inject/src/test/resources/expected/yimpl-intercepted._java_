/*
 * Copyright (c) {{year}} Oracle and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.helidon.inject.tests.inject.interceptor;

import java.io.IOException;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import io.helidon.common.Generated;
import io.helidon.common.types.AccessModifier;
import io.helidon.common.types.Annotation;
import io.helidon.common.types.ElementKind;
import io.helidon.common.types.TypeName;
import io.helidon.common.types.TypedElementInfo;
import io.helidon.inject.service.InterceptionMetadata;
import io.helidon.inject.service.Invoker;
import io.helidon.inject.service.Qualifier;
import io.helidon.inject.tests.plain.interceptor.IA;

/**
 * Intercepted sub-type for {@link io.helidon.inject.tests.inject.interceptor.YImpl}.
 */
@Generated(value = "io.helidon.inject.codegen.InterceptedTypeGenerator", trigger = "io.helidon.inject.tests.inject.interceptor.YImpl")
class YImpl__Intercepted extends YImpl {

    private static final TypedElementInfo METHOD_0_CLOSE = TypedElementInfo.builder()
            .kind(ElementKind.METHOD)
            .typeName(TypeName.create("void"))
            .elementName("close")
            .addAnnotation(Annotation.builder()
                    .typeName(TypeName.create("io.helidon.inject.tests.plain.interceptor.InterceptorBasedAnno"))
                    .putValue("value", "")
                    .build()
            )
            .accessModifier(AccessModifier.PUBLIC)
            .build();
    private static final TypedElementInfo METHOD_1_METHOD_IB = TypedElementInfo.builder()
            .kind(ElementKind.METHOD)
            .typeName(TypeName.create("void"))
            .elementName("methodIB")
            .addAnnotation(Annotation.builder()
                    .typeName(TypeName.create("io.helidon.inject.service.Injection.Named"))
                    .putValue("value", "methodIB")
                    .build()
            )
            .addAnnotation(Annotation.builder()
                    .typeName(TypeName.create("io.helidon.inject.tests.plain.interceptor.InterceptorBasedAnno"))
                    .putValue("value", "IBSubAnno")
                    .build()
            )
            .accessModifier(AccessModifier.PUBLIC)
            .addParameterArgument(TypedElementInfo.builder()
                    .kind(ElementKind.PARAMETER)
                    .typeName(TypeName.create("java.lang.String"))
                    .elementName("val")
                    .addAnnotation(Annotation.builder()
                            .typeName(TypeName.create("io.helidon.inject.service.Injection.Named"))
                            .putValue("value", "arg1")
                            .build()
                    )
                    .build()
            )
            .build();
    private static final TypedElementInfo METHOD_2_METHOD_IB2 = TypedElementInfo.builder()
            .kind(ElementKind.METHOD)
            .typeName(TypeName.create("java.lang.String"))
            .elementName("methodIB2")
            .addAnnotation(Annotation.builder()
                    .typeName(TypeName.create("io.helidon.inject.service.Injection.Named"))
                    .putValue("value", "methodIB2")
                    .build()
            )
            .addAnnotation(Annotation.builder()
                    .typeName(TypeName.create("io.helidon.inject.tests.plain.interceptor.InterceptorBasedAnno"))
                    .putValue("value", "IBSubAnno")
                    .build()
            )
            .accessModifier(AccessModifier.PUBLIC)
            .addParameterArgument(TypedElementInfo.builder()
                    .kind(ElementKind.PARAMETER)
                    .typeName(TypeName.create("java.lang.String"))
                    .elementName("val")
                    .addAnnotation(Annotation.builder()
                            .typeName(TypeName.create("io.helidon.inject.service.Injection.Named"))
                            .putValue("value", "arg1")
                            .build()
                    )
                    .build()
            )
            .build();

    private final Invoker<String> methodIB2_2_invoker;
    private final Invoker<Void> close_0_invoker;
    private final Invoker<Void> methodIB_1_invoker;

    YImpl__Intercepted(InterceptionMetadata helidonInject__interceptMeta, YImpl__ServiceDescriptor helidonInject__serviceDescriptor, Set<Qualifier> helidonInject__typeQualifiers, List<Annotation> helidonInject__typeAnnotations, Optional<IA> optionalIA) {
        super(optionalIA);

        this.close_0_invoker = helidonInject__interceptMeta.createInvoker(
            helidonInject__serviceDescriptor,
            helidonInject__typeQualifiers,
            helidonInject__typeAnnotations,
            METHOD_0_CLOSE,
            helidonInject__params -> {
                super.close();
                return null;
            }, Set.of(java.io.IOException.class));
        this.methodIB2_2_invoker = helidonInject__interceptMeta.createInvoker(
            helidonInject__serviceDescriptor,
            helidonInject__typeQualifiers,
            helidonInject__typeAnnotations,
            METHOD_2_METHOD_IB2,
            helidonInject__params -> super.methodIB2((java.lang.String) helidonInject__params[0]), Set.of());
        this.methodIB_1_invoker = helidonInject__interceptMeta.createInvoker(
            helidonInject__serviceDescriptor,
            helidonInject__typeQualifiers,
            helidonInject__typeAnnotations,
            METHOD_1_METHOD_IB,
            helidonInject__params -> {
                super.methodIB((java.lang.String) helidonInject__params[0]);
                return null;
            }, Set.of());
    }

    @Override
    public void close() throws IOException {
        try {
            close_0_invoker.invoke();
        } catch (IOException helidonInject__e) {
             throw helidonInject__e;
        } catch (RuntimeException helidonInject__e) {
            throw helidonInject__e;
        } catch (Exception helidonInject__e) {
            throw new RuntimeException(helidonInject__e);
        }
    }

    @Override
    public String methodIB2(String val) {
        try {
            return methodIB2_2_invoker.invoke(val);
        } catch (RuntimeException helidonInject__e) {
            throw helidonInject__e;
        } catch (Exception helidonInject__e) {
            throw new RuntimeException(helidonInject__e);
        }
    }

    @Override
    public void methodIB(String val) {
        try {
            methodIB_1_invoker.invoke(val);
        } catch (RuntimeException helidonInject__e) {
            throw helidonInject__e;
        } catch (Exception helidonInject__e) {
            throw new RuntimeException(helidonInject__e);
        }
    }

}
