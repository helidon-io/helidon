Service Inject Events
-----

Events allow in-application communication between services, by providing a mechanism to emit an event, and 
to create a consumer/consumers of events.

One event can be delivered to (0..n) consumers.

Basic terminology:
- `Event Producer` - a service that calls an emitter (origin of an event)
- `Event Emitter` - a service that emits an event to the event system
- `Event Object` - an arbitrary object that is sent around as an event
- `Event Observer` - a service that receives events, and has a method annotated with `io.helidon.service.inject.api.Event.Observer`
- `Qualified Event` - event published by an emitter providing a qualifier (annotation annotated with `Injection.Qualifier`)

# Emitting Events
Event Emitters are code generated by Helidon. To create an Event Producer, simply inject the emitter.
Event producers can be in any scope, the generated event emitter is always in `Injection.Singleton` scope.

A simple singleton service that injects an event emitter for event object of type `MyEventObject`.
```java
@Injection.Singleton
class MyService {
    private final Event.Emitter<MyEventObject> emitter;
    @Injection.Inject
    MyService(Event.Emitter<MyEventObject> emitter) {
        this.emitter = emitter;
    }
}
```

To emit an event, you simply call `emitter.emit(myEventObjectInstance)`.
The method will return once all event observers were notified (unless they are asynchronous - see below).
In case any of the observers throws an exception, an `EventDispatchException` will be thrown with all exceptions caught added as suppressed (i.e. we will invoke all observers, even after we catch an exception).

Event emitters are code generated for each Event Producer, so we may end up with more than one in the system. As all of them provide the exact same function, this is not an issue.

_Explanation of the above statement: we cannot code generate classes into packages that do not belong to the current module, so we always code generate the emitter to the same package as the service that needs the emitter. Even though this may duplicate code, it is the only safe way we can do during annotation processing (where we do not have access to the classpath of the application)_

# Consuming Events
An event can be consumed by declaring an observer method.
Event consumers can only be in `Injection.Singleton` or `Injection.PerLookup` scopes. The lookup is done exactly once, and all events are delivered to the same instance for the lifetime of the service registry.

Helidon code generates an `EventObserverRegistration` service, which is used by the event manager to gather all observers for event handling.

To create an event observer:
- create an observer method, with a single parameter of the event type you want to observe
- annotate the method with `Event.Observer`

Example:
```java
@Event.Observer
void event(MyEventObject eventObject) {
    // do something with the event
}
```

# Asynchronous Events
Events can be emitted asynchronously, and event observer can be asynchronous. 
Executor service for asynchronous events can be provided via service registry, as a service that implements contract 
`java.util.concurrent.ExecutorService`, and is named `io.helidon.service.inject.api.EventManager`. 
If none is provided, the service will use a thread per task executor with Virtual threads, thread names will be prefixed with `inject-event-manager-`.

## Asynchronous Event Producer

Rules of asynchronous event producing:
1. Method `Event.Emitter.emitAsync(..)` returns a `CompletionStage<MyEventType>`
2. All *synchronous* Event Consumer are submitted to an executor service, and the returned completion stage will provide either success (the event object itself), or will provide an exception, which will have `EventDispatchException` as a cause
3. The method returns once all the event observers are submitted to the executor service (there is no guarantee that anything has been delivered - we may have delivered 0 to n events (where n is number of synchronous observers))
4. All *asynchronous* Event Observer are invoked outside of the returned completion stage

## Asynchronous Observer

Asynchronous observer methods are invoked from separate threads (through the executor service mentioned above), and their results are ignored by the Event Emitter; if there is an exception thrown from the observer method, it is logged with `WARNING` log level into logger named `io.helidon.service.inject.api.EventManager`.

To declare an asynchronous observer use annotation `Event.AsyncObserver` instead of `Event.Observer`.

Example:
```java
@Event.AsyncObserver
void event(MyEventObject eventObject) {
    // handle event
}
```

# Qualified Events

A Qualified Event is only delivered to Event Consumers that use the same qualifier.

## Qualified Event Producer

A qualified event can be produced with two options:
1. The injection point of `Event.Emitter` (the constructor parameter, or field) is annotated with a qualifier annotation
2. The `Event.Emitter.emit(..)` method is called with explicit qualifier(s), note that if combined, the qualifier specified by the injection point will always be present! 

Example (combination of both):

```java
import io.helidon.service.inject.api.Qualifier;

// class declaration
private static final Qualifier BLUE = Qualifier.create(Blue.class);
@Injection.Inject
EventEmitter(@Black Event.Emitter<EventObject> event) {
    // the event producer will implicitly have Black qualifier added
    this.event = event;
}

void emit(MyEventObject eventObject) {
    // the event will be emitted with both Blue and Black qualifiers
    this.event.emit(eventObject, BLUE);
}
```

## Qualified Event Observers
To consume a qualified event, observer method must be annotated with the correct qualifier(s). 

Example:
```java
@Injection.Singleton
class EventObserver {
    @Event.Observer
    @Black
    void event(MyEventObject eventObject) {
        // handle event that is qualified with Black (and none other)
    }
}
```
