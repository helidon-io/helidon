/*
 * Copyright (c) 2024 Oracle and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.helidon.service.codegen;

import java.util.List;
import java.util.Set;

import io.helidon.codegen.CodegenException;
import io.helidon.codegen.CodegenUtil;
import io.helidon.codegen.classmodel.ClassModel;
import io.helidon.common.Weighted;
import io.helidon.common.types.AccessModifier;
import io.helidon.common.types.Annotations;
import io.helidon.common.types.ElementKind;
import io.helidon.common.types.TypeInfo;
import io.helidon.common.types.TypeName;
import io.helidon.common.types.TypeNames;

import static io.helidon.service.codegen.InjectionExtension.SET_OF_QUALIFIERS;
import static io.helidon.service.codegen.InjectionExtension.SET_OF_TYPES;
import static io.helidon.service.codegen.ServiceCodegenTypes.INJECTION_SINGLETON;
import static io.helidon.service.codegen.ServiceCodegenTypes.INJECT_SERVICE_DESCRIPTOR;
import static io.helidon.service.codegen.ServiceCodegenTypes.INTERCEPTION_FACTORY;
import static io.helidon.service.codegen.ServiceCodegenTypes.INTERCEPTION_METADATA;

/**
 * Tools for interception of non-service interfaces. Classes (even abstract) cannot be used,
 * as we do not know how to instantiate them.
 * <p>
 * The generated factory always works with delegation, so this is not the right way to handle
 * service interception (which is done automatically).
 */
public final class InterceptionSupport {
    private static final TypeName GENERATOR = TypeName.create(InterceptionSupport.class);
    private static final TypeName DESCRIPTOR_TYPE = TypeName.builder(INJECT_SERVICE_DESCRIPTOR)
            .addTypeArgument(TypeName.create("?"))
            .build();
    private static final String INTERCEPT_META_PARAM = "interceptMeta";
    private static final String DESCRIPTOR_PARAM = "descriptor";
    private static final String TYPE_ANNOTATIONS_FIELD = "ANNOTATIONS";
    private static final String DELEGATE_PARAM = "delegate";

    private final RegistryCodegenContext ctx;
    private final Interception interception;

    private InterceptionSupport(RegistryCodegenContext ctx, Interception interception) {
        this.ctx = ctx;
        this.interception = interception;
    }

    /**
     * Create a new instance.
     *
     * @param ctx codegen context
     * @return a new interception support instance
     */
    public static InterceptionSupport create(RegistryCodegenContext ctx) {
        return new InterceptionSupport(ctx,
                                       new Interception(InjectOptions.INTERCEPTION_STRATEGY.value(ctx.options())));
    }

    /**
     * Check whether the provided type has an intercepted annotation (anywhere, including super types).
     *
     * @param typeInfo type info of the analyzed type
     * @return {@code true} if the interface may be intercepted
     */
    public boolean intercepted(TypeInfo typeInfo) {
        if (typeInfo.kind() != ElementKind.INTERFACE) {
            return false;
        }
        return !interception.maybeIntercepted(typeInfo).isEmpty();
    }

    /**
     * Generates required code to handle interception by delegation.
     * <p>
     * Creates the following types:
     * <ul>
     *     <li>Type__InterceptedDelegate - the type implementing interception, package private</li>
     *     <li>Type__InterceptedFactoryDescriptor - service descriptor and implementation of the factory to create
     *     intercepted instance</li>
     * </ul>
     *
     * Usage: When processing types, you can call this method to generate the types above. This is not done automatically,
     * as we do not know which interface is the "right" one to intercept (there may be a generated type, or it may be implemented
     * directly by a service, in which case the interception is generated by Helidon automatically).
     * Once your service provider creates an instance, just call the factory yourself to wrap the instance.
     * The steps you need to do:
     * <ol>
     *     <li>Inject {@code Interception.Factory<Type>} named by the interface class name</li>
     *     <li>Invoke {@code factory.create(ServiceDescriptor.INSTANCE, instance)} to wrap your instance, the service
     *     descriptor must be your descriptor that describes the service</li>
     * </ol>
     * This is used from Helidon Config Beans, so you can check appropriate code in
     * {@code io.helidon.service.codegen.ConfigBeanCodegen}.
     *
     * @param typeInfo interface type info that will be intercepted
     * @param interfaceType type of the interface used for interception (may differ from typeInfo type)
     * @throws io.helidon.codegen.CodegenException in case the type is not an interface
     */
    public void generateDelegateInterception(TypeInfo typeInfo, TypeName interfaceType) {
        if (typeInfo.kind() != ElementKind.INTERFACE) {
            throw new CodegenException("We can generate a delegate interception only for interfaces, but "
                                               + typeInfo.typeName().fqName() + " is " + typeInfo.kind(),
                                       typeInfo.originatingElementValue());
        }

        List<TypedElements.ElementMeta> elementMetas = interception.maybeIntercepted(typeInfo);
        generateIntercepted(typeInfo, interfaceType, elementMetas);
        generateInterceptedFactory(typeInfo, interfaceType);
    }

    /**
     * Type name for the intercepted delegate generated type.
     *
     * @param interfaceType type of the interface
     * @return type name that will be generated for it
     */
    public TypeName interceptedDelegateType(TypeName interfaceType) {
        return TypeName.builder()
                .packageName(interfaceType.packageName())
                .className(interfaceType.classNameWithEnclosingNames().replace('.', '_') + "__InterceptedDelegate")
                .build();
    }

    /**
     * Type name for the generated service descriptor for intercepted factory.
     *
     * @param interfaceType type info of the interface
     * @return type name that will be generated for it
     */
    public TypeName interceptedFactoryDescriptorType(TypeName interfaceType) {
        return TypeName.builder()
                .packageName(interfaceType.packageName())
                .className(interfaceType.classNameWithEnclosingNames().replace('.', '_')
                                   + "__InterceptedFactoryDescriptor")
                .build();
    }

    private void generateInterceptedFactory(TypeInfo typeInfo, TypeName interfaceType) {
        TypeName generatedType = interceptedFactoryDescriptorType(interfaceType);

        var classModel = ClassModel.builder()
                .accessModifier(AccessModifier.PUBLIC)
                .addInterface(descriptorTypeName(interfaceType))
                .type(generatedType)
                .copyright(CodegenUtil.copyright(GENERATOR,
                                                 typeInfo.typeName(),
                                                 generatedType))
                .description("Intercepted interface implementation, that delegates to the provided instance.")
                .addAnnotation(CodegenUtil.generatedAnnotation(GENERATOR,
                                                               typeInfo.typeName(),
                                                               generatedType,
                                                               "",
                                                               ""));

        // singleton
        classModel.addField(singleton -> singleton
                .accessModifier(AccessModifier.PUBLIC)
                .isStatic(true)
                .isFinal(true)
                .description("Instance for service registry.")
                .type(generatedType)
                .name("INSTANCE")
                .addContent("new ")
                .addContent(generatedType)
                .addContent("()"));
        // type
        classModel.addField(singleton -> singleton
                .accessModifier(AccessModifier.PRIVATE)
                .isStatic(true)
                .isFinal(true)
                .type(TypeNames.TYPE_NAME)
                .name("TYPE")
                .addContentCreate(generatedType));

        // qualifier
        classModel.addField(singleton -> singleton
                .accessModifier(AccessModifier.PRIVATE)
                .isStatic(true)
                .isFinal(true)
                .type(ServiceCodegenTypes.INJECT_QUALIFIER)
                .name("NAMED")
                .addContent(ServiceCodegenTypes.INJECT_QUALIFIER)
                .addContent(".createNamed(\"")
                .addContent(interfaceType.fqName())
                .addContent("\")"));

        // constructor does nothing
        classModel.addConstructor(ctr -> ctr.accessModifier(AccessModifier.PRIVATE));

        // and the methods
        classModel.addMethod(qualifiers -> qualifiers
                .name("qualifiers")
                .accessModifier(AccessModifier.PUBLIC)
                .returnType(SET_OF_QUALIFIERS)
                .addAnnotation(Annotations.OVERRIDE)
                .addContent("return ")
                .addContent(Set.class)
                .addContentLine(".of(NAMED);"));
        classModel.addMethod(scope -> scope
                .name("scope")
                .accessModifier(AccessModifier.PUBLIC)
                .returnType(TypeNames.TYPE_NAME)
                .addAnnotation(Annotations.OVERRIDE)
                .addContent("return ")
                .addContent(INJECTION_SINGLETON)
                .addContentLine(".TYPE;"));
        classModel.addMethod(serviceType -> serviceType
                .name("serviceType")
                .accessModifier(AccessModifier.PUBLIC)
                .returnType(TypeNames.TYPE_NAME)
                .addAnnotation(Annotations.OVERRIDE)
                .addContentLine("return TYPE;"));
        classModel.addMethod(descriptorType -> descriptorType
                .name("descriptorType")
                .accessModifier(AccessModifier.PUBLIC)
                .returnType(TypeNames.TYPE_NAME)
                .addAnnotation(Annotations.OVERRIDE)
                .addContentLine("return TYPE;"));
        classModel.addMethod(contracts -> contracts
                .name("contracts")
                .accessModifier(AccessModifier.PUBLIC)
                .returnType(SET_OF_TYPES)
                .addAnnotation(Annotations.OVERRIDE)
                .addContent("return ")
                .addContent(Set.class)
                .addContent(".of(")
                .addContent(INTERCEPTION_FACTORY)
                .addContentLine(".TYPE);"));
        classModel.addMethod(instantiate -> instantiate
                .name("instantiate")
                .accessModifier(AccessModifier.PUBLIC)
                .returnType(TypeNames.OBJECT)
                .addAnnotation(Annotations.OVERRIDE)
                .addParameter(ctxParam -> ctxParam.type(ServiceCodegenTypes.SERVICE_DEPENDENCY_CONTEXT)
                        .name("ctx"))
                .addParameter(interceptMeta -> interceptMeta.type(INTERCEPTION_METADATA)
                        .name("interceptMeta"))
                .addContentLine("return new FactoryImpl(interceptMeta);"));

        // and finally the factory implementation
        classModel.addInnerClass(factoryImpl -> factoryImpl
                .accessModifier(AccessModifier.PRIVATE)
                .isStatic(true)
                .name("FactoryImpl")
                .addInterface(factoryTypeName(interfaceType))
                .addField(interceptMeta -> interceptMeta
                        .accessModifier(AccessModifier.PRIVATE)
                        .isFinal(true)
                        .type(INTERCEPTION_METADATA)
                        .name("interceptMeta"))
                .addConstructor(ctr -> ctr
                        .accessModifier(AccessModifier.PRIVATE)
                        .addParameter(interceptMeta -> interceptMeta.type(INTERCEPTION_METADATA)
                                .name("interceptMeta"))
                        .addContentLine("this.interceptMeta = interceptMeta;"))
                .addMethod(create -> create
                        .name("create")
                        .accessModifier(AccessModifier.PUBLIC)
                        .addAnnotation(Annotations.OVERRIDE)
                        .returnType(interfaceType)
                        .addParameter(descriptor -> descriptor
                                .name("descriptor")
                                .type(DESCRIPTOR_TYPE))
                        .addParameter(delegate -> delegate
                                .name("delegate")
                                .type(interfaceType))
                        .addContent("return ")
                        .addContent(interceptedDelegateType(interfaceType))
                        .addContentLine(".create(")
                        .increaseContentPadding()
                        .increaseContentPadding()
                        .addContentLine("interceptMeta,")
                        .addContentLine("descriptor,")
                        .addContentLine("delegate);")
                )
        );

        ctx.addDescriptor("inject",
                          generatedType,
                          generatedType,
                          classModel,
                          Weighted.DEFAULT_WEIGHT,
                          Set.of(INTERCEPTION_FACTORY),
                          typeInfo.originatingElementValue());
    }

    private TypeName descriptorTypeName(TypeName interfaceType) {
        return TypeName.builder(INJECT_SERVICE_DESCRIPTOR)
                .addTypeArgument(factoryTypeName(interfaceType))
                .build();
    }

    private TypeName factoryTypeName(TypeName interfaceType) {
        return TypeName.builder(INTERCEPTION_FACTORY)
                .addTypeArgument(interfaceType)
                .build();
    }

    private void generateIntercepted(TypeInfo typeInfo, TypeName interfaceType, List<TypedElements.ElementMeta> elementMetas) {
        TypeName generatedType = interceptedDelegateType(interfaceType);
        var definitions = InterceptedTypeGenerator.MethodDefinition.toDefinitions(ctx, typeInfo, elementMetas);

        var classModel = ClassModel.builder()
                .accessModifier(AccessModifier.PACKAGE_PRIVATE)
                .addInterface(interfaceType)
                .type(generatedType)
                .copyright(CodegenUtil.copyright(GENERATOR,
                                                 interfaceType,
                                                 generatedType))
                .description("Intercepted interface implementation, that delegates to the provided instance.")
                .addAnnotation(CodegenUtil.generatedAnnotation(GENERATOR,
                                                               interfaceType,
                                                               generatedType,
                                                               "",
                                                               ""));

        // add type annotations
        InjectionExtension.annotationsField(classModel, typeInfo);
        // this is a special case, where we may not have the correct descriptor
        InterceptedTypeGenerator.generateElementInfoFields(classModel, definitions);
        InterceptedTypeGenerator.generateInvokerFields(classModel, definitions);
        InterceptedTypeGenerator.generateInterceptedMethods(classModel, definitions);

        classModel.addConstructor(ctr -> ctr
                .accessModifier(AccessModifier.PRIVATE)
                .addParameter(interceptMeta -> interceptMeta
                        .type(INTERCEPTION_METADATA)
                        .name(INTERCEPT_META_PARAM))
                .addParameter(descriptor -> descriptor
                        .type(DESCRIPTOR_TYPE)
                        .name(DESCRIPTOR_PARAM))
                .addParameter(delegate -> delegate
                        .type(interfaceType)
                        .name(DELEGATE_PARAM))
                .update(it -> InterceptedTypeGenerator.createInvokers(it,
                                                                      definitions,
                                                                      false,
                                                                      INTERCEPT_META_PARAM,
                                                                      DESCRIPTOR_PARAM,
                                                                      DESCRIPTOR_PARAM + ".qualifiers()",
                                                                      TYPE_ANNOTATIONS_FIELD,
                                                                      DELEGATE_PARAM)));

        // and finally the create method (to be invoked by factory)
        classModel.addMethod(create -> create
                .accessModifier(AccessModifier.PACKAGE_PRIVATE)
                .isStatic(true)
                .returnType(interfaceType)
                .name("create")
                .addParameter(interceptMeta -> interceptMeta
                        .type(INTERCEPTION_METADATA)
                        .name(INTERCEPT_META_PARAM))
                .addParameter(descriptor -> descriptor
                        .type(DESCRIPTOR_TYPE)
                        .name(DESCRIPTOR_PARAM))
                .addParameter(delegate -> delegate
                        .type(interfaceType)
                        .name(DELEGATE_PARAM))
                .addContent("return new ")
                .addContent(generatedType)
                .addContent("(")
                .addContent(INTERCEPT_META_PARAM)
                .addContentLine(",")
                .increaseContentPadding()
                .increaseContentPadding()
                .addContent(DESCRIPTOR_PARAM)
                .addContentLine(",")
                .addContent(DELEGATE_PARAM)
                .addContentLine(");")
        );

        ctx.addType(generatedType, classModel, interfaceType, typeInfo.originatingElementValue());
    }
}
