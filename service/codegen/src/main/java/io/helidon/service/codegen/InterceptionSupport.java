/*
 * Copyright (c) 2024 Oracle and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.helidon.service.codegen;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import io.helidon.codegen.CodegenException;
import io.helidon.codegen.CodegenUtil;
import io.helidon.codegen.ElementInfoPredicates;
import io.helidon.codegen.classmodel.ClassModel;
import io.helidon.common.types.AccessModifier;
import io.helidon.common.types.Annotations;
import io.helidon.common.types.ElementKind;
import io.helidon.common.types.ElementSignature;
import io.helidon.common.types.TypeInfo;
import io.helidon.common.types.TypeName;
import io.helidon.common.types.TypeNames;
import io.helidon.common.types.TypedElementInfo;

import static io.helidon.service.codegen.ServiceCodegenTypes.INJECT_SERVICE_DESCRIPTOR;
import static io.helidon.service.codegen.ServiceCodegenTypes.INTERCEPTION_METADATA;

/**
 * Tools for interception of non-service interfaces. Classes (even abstract) cannot be used,
 * as we do not know how to instantiate them.
 */
public final class InterceptionSupport {
    private static final TypeName GENERATOR = TypeName.create(InterceptionSupport.class);
    private static final TypeName DESCRIPTOR_TYPE = TypeName.builder(INJECT_SERVICE_DESCRIPTOR)
            .addTypeArgument(TypeName.create("?"))
            .build();
    private static final String INTERCEPT_META_PARAM = "interceptMeta";
    private static final String DESCRIPTOR_PARAM = "descriptor";
    private static final String TYPE_ANNOTATIONS_FIELD = "ANNOTATIONS";
    private static final String DELEGATE_PARAM = "delegate";

    private final RegistryCodegenContext ctx;
    private final Interception interception;

    private InterceptionSupport(RegistryCodegenContext ctx, Interception interception) {
        this.ctx = ctx;
        this.interception = interception;
    }

    /**
     * Create a new instance.
     *
     * @param ctx codegen context
     * @return a new interception support instance
     */
    public static InterceptionSupport create(RegistryCodegenContext ctx) {
        return new InterceptionSupport(ctx,
                                       new Interception(InjectOptions.INTERCEPTION_STRATEGY.value(ctx.options())));
    }

    /**
     * Check whether the provided type has an intercepted annotation (anywhere, including super types).
     *
     * @param typeInfo type info of the analyzed type
     * @return {@code true} if the interface may be intercepted
     */
    public boolean intercepted(TypeInfo typeInfo) {
        if (typeInfo.kind() != ElementKind.INTERFACE) {
            return false;
        }
        return !interception.maybeIntercepted(typeInfo).isEmpty();
    }

    /**
     * Generates required code to handle interception by delegation.
     * <p>
     * Creates the following types:
     * <ul>
     *     <li>Type__InterceptedDelegate - the type implementing interception, package private</li>
     * </ul>
     *
     * Usage: When processing types, you can call this method to generate the types above. This is not done automatically,
     * as we do not know which interface is the "right" one to intercept (there may be a generated type, or it may be implemented
     * directly by a service, in which case the interception is generated by Helidon automatically).
     * The steps you need to do:
     * <ol>
     *     <li>Invoke {@code Contract__InterceptedDelegate.create(interceptMeta, ServiceDescriptor.INSTANCE, instance)}
     *     to wrap your instance, the service descriptor must be your descriptor that describes the service</li>
     * </ol>
     * This is used from Helidon Config Beans, so you can check appropriate code in
     * {@code io.helidon.service.codegen.ConfigBeanCodegen}.
     *
     * @param typeInfo      interface type info that will be intercepted
     * @param interfaceType type of the interface used for interception (may differ from typeInfo type)
     * @return type name of the generated delegate implementation
     * @throws io.helidon.codegen.CodegenException in case the type is not an interface
     */
    public TypeName generateDelegateInterception(TypeInfo typeInfo, TypeName interfaceType) {
        if (typeInfo.kind() != ElementKind.INTERFACE) {
            throw new CodegenException("We can generate a delegate interception only for interfaces, but "
                                               + typeInfo.typeName().fqName() + " is " + typeInfo.kind(),
                                       typeInfo.originatingElementValue());
        }

        List<TypedElements.ElementMeta> elementMetas = interception.maybeIntercepted(typeInfo);
        Set<ElementSignature> interceptedSignatures = new HashSet<>();
        elementMetas.stream()
                .map(TypedElements.ElementMeta::element)
                .map(TypedElementInfo::signature)
                .forEach(interceptedSignatures::add);
        List<TypedElementInfo> otherMethods = typeInfo.elementInfo()
                .stream()
                .filter(ElementInfoPredicates::isMethod)
                .filter(Predicate.not(ElementInfoPredicates::isStatic))
                .filter(Predicate.not(ElementInfoPredicates::isPrivate))
                .filter(it -> !interceptedSignatures.contains(it.signature()))
                .collect(Collectors.toUnmodifiableList());
        return generateIntercepted(typeInfo, interfaceType, elementMetas, otherMethods);
    }

    /**
     * Type name for the intercepted delegate generated type.
     *
     * @param interfaceType type of the interface
     * @return type name that will be generated for it
     */
    public TypeName interceptedDelegateType(TypeName interfaceType) {
        return TypeName.builder()
                .packageName(interfaceType.packageName())
                .className(interfaceType.classNameWithEnclosingNames().replace('.', '_') + "__InterceptedDelegate")
                .build();
    }

    private TypeName generateIntercepted(TypeInfo typeInfo,
                                         TypeName interfaceType,
                                         List<TypedElements.ElementMeta> elementMetas,
                                         List<TypedElementInfo> otherMethods) {

        TypeName generatedType = interceptedDelegateType(interfaceType);
        var definitions = InterceptedTypeGenerator.MethodDefinition.toDefinitions(ctx, typeInfo, elementMetas);

        var classModel = ClassModel.builder()
                .accessModifier(AccessModifier.PACKAGE_PRIVATE)
                .addInterface(interfaceType)
                .type(generatedType)
                .copyright(CodegenUtil.copyright(GENERATOR,
                                                 interfaceType,
                                                 generatedType))
                .description("Intercepted interface implementation, that delegates to the provided instance.")
                .addAnnotation(CodegenUtil.generatedAnnotation(GENERATOR,
                                                               interfaceType,
                                                               generatedType,
                                                               "",
                                                               ""));

        // add type annotations
        InjectionExtension.annotationsField(classModel, typeInfo);
        // this is a special case, where we may not have the correct descriptor
        InterceptedTypeGenerator.generateElementInfoFields(classModel, definitions);
        InterceptedTypeGenerator.generateInvokerFields(classModel, definitions);
        InterceptedTypeGenerator.generateInterceptedMethods(classModel, definitions);
        generateOtherMethods(classModel, otherMethods);

        classModel.addField(delegate -> delegate
                .name(DELEGATE_PARAM)
                .accessModifier(AccessModifier.PRIVATE)
                .isFinal(true)
                .type(interfaceType));

        classModel.addConstructor(ctr -> ctr
                .accessModifier(AccessModifier.PRIVATE)
                .addParameter(interceptMeta -> interceptMeta
                        .type(INTERCEPTION_METADATA)
                        .name(INTERCEPT_META_PARAM))
                .addParameter(descriptor -> descriptor
                        .type(DESCRIPTOR_TYPE)
                        .name(DESCRIPTOR_PARAM))
                .addParameter(delegate -> delegate
                        .type(interfaceType)
                        .name(DELEGATE_PARAM))
                .addContent("this.")
                .addContent(DELEGATE_PARAM)
                .addContent(" = ")
                .addContent(DELEGATE_PARAM)
                .addContentLine(";")
                .update(it -> InterceptedTypeGenerator.createInvokers(it,
                                                                      definitions,
                                                                      false,
                                                                      INTERCEPT_META_PARAM,
                                                                      DESCRIPTOR_PARAM,
                                                                      DESCRIPTOR_PARAM + ".qualifiers()",
                                                                      TYPE_ANNOTATIONS_FIELD,
                                                                      DELEGATE_PARAM)));

        // and finally the create method (to be invoked by user code)
        classModel.addMethod(create -> create
                .accessModifier(AccessModifier.PACKAGE_PRIVATE)
                .isStatic(true)
                .returnType(interfaceType)
                .name("create")
                .addParameter(interceptMeta -> interceptMeta
                        .type(INTERCEPTION_METADATA)
                        .name(INTERCEPT_META_PARAM))
                .addParameter(descriptor -> descriptor
                        .type(DESCRIPTOR_TYPE)
                        .name(DESCRIPTOR_PARAM))
                .addParameter(delegate -> delegate
                        .type(interfaceType)
                        .name(DELEGATE_PARAM))
                .addContent("return new ")
                .addContent(generatedType)
                .addContent("(")
                .addContent(INTERCEPT_META_PARAM)
                .addContentLine(",")
                .increaseContentPadding()
                .increaseContentPadding()
                .addContent(DESCRIPTOR_PARAM)
                .addContentLine(",")
                .addContent(DELEGATE_PARAM)
                .addContentLine(");")
        );

        ctx.addType(generatedType, classModel, interfaceType, typeInfo.originatingElementValue());

        return generatedType;
    }

    private void generateOtherMethods(ClassModel.Builder classModel, List<TypedElementInfo> otherMethods) {
        for (TypedElementInfo info : otherMethods) {
            classModel.addMethod(method -> method
                    .addAnnotation(Annotations.OVERRIDE)
                    .name(info.elementName())
                    .accessModifier(info.accessModifier())
                    .name(info.elementName())
                    .returnType(info.typeName())
                    .update(it -> info.parameterArguments().forEach(arg -> it.addParameter(param -> param.type(arg.typeName())
                            .name(arg.elementName()))))
                    .update(it -> {
                        // add throws statements
                        for (TypeName checkedException : info.throwsChecked()) {
                            it.addThrows(checkedException, "");
                        }
                    })
                    .update(it -> {
                        // body
                        if (!info.typeName().equals(TypeNames.PRIMITIVE_VOID)) {
                            it.addContent("return ");
                        }
                        it.addContent(DELEGATE_PARAM)
                                .addContent(".")
                                .addContent(info.elementName())
                                .addContent("(");

                        it.addContent(info.parameterArguments()
                                              .stream()
                                              .map(TypedElementInfo::elementName)
                                              .collect(Collectors.joining(", ")));

                        it.addContentLine(");");
                    }));
        }

    }
}
