/*
 * Copyright (c) 2026 Oracle and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.helidon.webserver.observe.telemetry.metrics;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Implementation of MetricsEnvelop. Mostly generated by Oracle generative chat.
 */
public final class MetricsEnvelopeImpl implements MetricsEnvelope {
    private final Resource resource;
    private final List<ScopeMetrics> scopeMetrics;

    public MetricsEnvelopeImpl(Resource resource, List<ScopeMetrics> scopeMetrics) {
        this.resource = resource;
        this.scopeMetrics = scopeMetrics == null ? List.of() : List.copyOf(scopeMetrics);
    }

    @Override public Resource resource() { return resource; }
    @Override public List<ScopeMetrics> scopeMetrics() { return scopeMetrics; }

    // ---- nested implementation types (return interface types) ----

    public static final class ResourceImpl implements MetricsEnvelope.Resource {
        private final Map<String, AnyValue> attributes;

        public ResourceImpl(Map<String, AnyValue> attributes) {
            this.attributes = attributes == null ? Map.of() : Map.copyOf(attributes);
        }

        @Override public Map<String, AnyValue> attributes() { return attributes; }
    }

    public static final class ScopeMetricsImpl implements MetricsEnvelope.ScopeMetrics {
        private final InstrumentationScope scope;
        private final List<Metric> metrics;

        public ScopeMetricsImpl(InstrumentationScope scope, List<Metric> metrics) {
            this.scope = scope;
            this.metrics = metrics == null ? List.of() : List.copyOf(metrics);
        }

        @Override public InstrumentationScope scope() { return scope; }
        @Override public List<Metric> metrics() { return metrics; }
    }

    public static final class InstrumentationScopeImpl implements MetricsEnvelope.InstrumentationScope {
        private final String name;
        private final Map<String, AnyValue> attributes;

        public InstrumentationScopeImpl(String name, Map<String, AnyValue> attributes) {
            this.name = name;
            this.attributes = attributes == null ? Map.of() : Map.copyOf(attributes);
        }

        @Override public String name() {
            return name;
        }

        @Override public Map<String, AnyValue> attributes() {
            return attributes;
        }
    }

    public static final class MetricImpl implements MetricsEnvelope.Metric {
        private final String name;
        private final String description;
        private final String unit;
        private final Histogram histogram; // nullable

        public MetricImpl(String name, String description, String unit, Histogram histogram) {
            this.name = name;
            this.description = description;
            this.unit = unit;
            this.histogram = histogram;
        }

        @Override public String name() { return name; }
        @Override public String description() { return description; }
        @Override public String unit() { return unit; }
        @Override public Histogram histogram() { return histogram; }
    }

    public static final class HistogramImpl implements MetricsEnvelope.Histogram {
        private final Integer aggregationTemporality;
        private final List<HistogramDataPoint> dataPoints;

        public HistogramImpl(Integer aggregationTemporality, List<HistogramDataPoint> dataPoints) {
            this.aggregationTemporality = aggregationTemporality;
            this.dataPoints = dataPoints == null ? List.of() : List.copyOf(dataPoints);
        }

        @Override public Integer aggregationTemporality() { return aggregationTemporality; }
        @Override public List<HistogramDataPoint> dataPoints() { return dataPoints; }
    }

    public static final class HistogramDataPointImpl implements MetricsEnvelope.HistogramDataPoint {
        private final String startTimeUnixNano;
        private final String timeUnixNano;
        private final Integer count;
        private final Double sum;
        private final Double min;
        private final Double max;
        private final List<String> bucketCounts;
        private final List<Double> explicitBounds;
        private final Map<String, AnyValue> attributes;

        public HistogramDataPointImpl(
                String startTimeUnixNano,
                String timeUnixNano,
                Integer count,
                Double sum,
                Double min,
                Double max,
                List<String> bucketCounts,
                List<Double> explicitBounds,
                Map<String, AnyValue> attributes
        ) {
            this.startTimeUnixNano = startTimeUnixNano;
            this.timeUnixNano = timeUnixNano;
            this.count = count;
            this.sum = sum;
            this.min = min;
            this.max = max;
            this.bucketCounts = bucketCounts == null ? List.of() : List.copyOf(bucketCounts);
            this.explicitBounds = explicitBounds == null ? List.of() : List.copyOf(explicitBounds);
            this.attributes = attributes == null ? Map.of() : Map.copyOf(attributes);
        }

        @Override public String startTimeUnixNano() { return startTimeUnixNano; }
        @Override public String timeUnixNano() { return timeUnixNano; }
        @Override public Integer count() { return count; }
        @Override public Double sum() { return sum; }
        @Override public Double min() { return min; }
        @Override public Double max() { return max; }
        @Override public List<String> bucketCounts() { return bucketCounts; }
        @Override public List<Double> explicitBounds() { return explicitBounds; }
        @Override public Map<String, AnyValue> attributes() { return attributes; }
    }

    public static final class AnyValueImpl implements MetricsEnvelope.AnyValue {
        private final String stringValue;
        private final String intValue;
        private final Double doubleValue;
        private final Boolean boolValue;
        private final Map<String, Object> raw;

        public AnyValueImpl(String stringValue, String intValue, Double doubleValue, Boolean boolValue,
                            Map<String, Object> raw) {
            this.stringValue = stringValue;
            this.intValue = intValue;
            this.doubleValue = doubleValue;
            this.boolValue = boolValue;
            this.raw = raw == null ? Collections.emptyMap() : Collections.unmodifiableMap(raw);
        }

        @Override public Optional<String> asString() { return Optional.ofNullable(stringValue); }

        @Override public Optional<Long> asLong() {
            if (intValue == null) return Optional.empty();
            try { return Optional.of(Long.parseLong(intValue)); }
            catch (NumberFormatException e) { return Optional.empty(); }
        }

        @Override public Optional<Double> asDouble() { return Optional.ofNullable(doubleValue); }
        @Override public Optional<Boolean> asBoolean() { return Optional.ofNullable(boolValue); }
        @Override public Map<String, Object> raw() { return raw; }
    }
}
