/*
 * Copyright (c) 2026 Oracle and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.helidon.webserver.observe.telemetry.metrics;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import jakarta.json.Json;
import jakarta.json.JsonArray;
import jakarta.json.JsonNumber;
import jakarta.json.JsonObject;
import jakarta.json.JsonReader;
import jakarta.json.JsonString;
import jakarta.json.JsonValue;

import jakarta.json.stream.JsonParsingException;

/**
 * Translates OpenTelemetry JSON metrics output into the corresponding POJO types. Mostly generated by Oracle generative chat.
 */
public final class OtlpJsonpMetricsParser {

    static OtlpJsonpMetricsParser create() {
        return new OtlpJsonpMetricsParser();
    }

    /** Always returns a single top-level export object; accepts wrapped or unwrapped input. */
    public MetricsExport parse(String json) {
        try (JsonReader reader = Json.createReader(new StringReader(json))) {
            JsonValue rootVal = reader.readValue();
            if (rootVal == null) return new MetricsExportImpl(List.of());

            return switch (rootVal.getValueType()) {
                case OBJECT -> parseFromObject(rootVal.asJsonObject());
                case ARRAY -> parseFromArray(rootVal.asJsonArray()); // optional convenience
                default -> throw new IllegalArgumentException("Expected JSON object/array but got: " + rootVal.getValueType());
            };
        } catch (JsonParsingException e) {
            throw new IllegalArgumentException("Invalid JSON", e);
        }
    }

    private MetricsExport parseFromObject(JsonObject root) {
        // Wrapped: { "resourceMetrics": [ ... ] } (or snake_case)
        JsonArray rm = arr(root, "resourceMetrics");
        if (rm == null) rm = arr(root, "resource_metrics");
        if (rm != null) {
            List<MetricsEnvelope> envs = new ArrayList<>(rm.size());
            for (JsonValue v : rm) envs.add(parseEnvelope(asObject(v)));
            return new MetricsExportImpl(envs);
        }

        // Unwrapped: { "resource": ..., "scopeMetrics": ... }
        if (obj(root, "resource") != null || arr(root, "scopeMetrics") != null || arr(root, "scope_metrics") != null) {
            return new MetricsExportImpl(List.of(parseEnvelope(root)));
        }

        throw new IllegalArgumentException(
                "Unrecognized metrics JSON shape. Expected {resource,scopeMetrics} or {resourceMetrics:[...]}"
        );
    }

    private MetricsExport parseFromArray(JsonArray rootArray) {
        List<MetricsEnvelope> envs = new ArrayList<>(rootArray.size());
        for (JsonValue v : rootArray) envs.add(parseEnvelope(asObject(v)));
        return new MetricsExportImpl(envs);
    }

    // ---- Single-envelope parsing (ResourceMetrics-like) ----

    private MetricsEnvelope parseEnvelope(JsonObject root) {
        MetricsEnvelope.Resource resource = parseResource(obj(root, "resource"));

        JsonArray scopeMetricsArr = arr(root, "scopeMetrics");
        if (scopeMetricsArr == null) scopeMetricsArr = arr(root, "scope_metrics");

        List<MetricsEnvelope.ScopeMetrics> scopeMetrics = parseScopeMetricsArray(scopeMetricsArr);
        return new MetricsEnvelopeImpl(resource, scopeMetrics);
    }

    private MetricsEnvelope.Resource parseResource(JsonObject resourceObj) {
        if (resourceObj == null) return new MetricsEnvelopeImpl.ResourceImpl(Map.of());
        Map<String, MetricsEnvelope.AnyValue> attrs = parseAttributesMap(arr(resourceObj, "attributes"));
        return new MetricsEnvelopeImpl.ResourceImpl(attrs);
    }

    private List<MetricsEnvelope.ScopeMetrics> parseScopeMetricsArray(JsonArray a) {
        if (a == null) return List.of();
        List<MetricsEnvelope.ScopeMetrics> out = new ArrayList<>(a.size());
        for (JsonValue v : a) {
            JsonObject o = asObject(v);

            MetricsEnvelope.InstrumentationScope scope = parseScope(obj(o, "scope"));
            List<MetricsEnvelope.Metric> metrics = parseMetricsArray(arr(o, "metrics"));

            out.add(new MetricsEnvelopeImpl.ScopeMetricsImpl(scope, metrics));
        }
        return List.copyOf(out);
    }

    private MetricsEnvelope.InstrumentationScope parseScope(JsonObject scopeObj) {
        if (scopeObj == null)
            return new MetricsEnvelopeImpl.InstrumentationScopeImpl(null, Map.of());
        String name = str(scopeObj, "name");
        Map<String, MetricsEnvelope.AnyValue> attrs = parseAttributesMap(arr(scopeObj, "attributes"));
        return new MetricsEnvelopeImpl.InstrumentationScopeImpl(name, attrs);
    }

    private List<MetricsEnvelope.Metric> parseMetricsArray(JsonArray a) {
        if (a == null) return List.of();
        List<MetricsEnvelope.Metric> out = new ArrayList<>(a.size());
        for (JsonValue v : a) {
            JsonObject o = asObject(v);

            String name = str(o, "name");
            String desc = str(o, "description");
            String unit = str(o, "unit");

            MetricsEnvelope.Histogram hist = null;
            JsonObject histObj = obj(o, "histogram");
            if (histObj != null) hist = parseHistogram(histObj);

            out.add(new MetricsEnvelopeImpl.MetricImpl(name, desc, unit, hist));
        }
        return List.copyOf(out);
    }

    private MetricsEnvelope.Histogram parseHistogram(JsonObject histObj) {
        Integer temporality = integer(histObj, "aggregationTemporality");
        if (temporality == null) temporality = integer(histObj, "aggregation_temporality");

        JsonArray dps = arr(histObj, "dataPoints");
        if (dps == null) dps = arr(histObj, "data_points");

        List<MetricsEnvelope.HistogramDataPoint> points = parseHistogramDataPoints(dps);
        return new MetricsEnvelopeImpl.HistogramImpl(temporality, points);
    }

    private List<MetricsEnvelope.HistogramDataPoint> parseHistogramDataPoints(JsonArray a) {
        if (a == null) return List.of();
        List<MetricsEnvelope.HistogramDataPoint> out = new ArrayList<>(a.size());

        for (JsonValue v : a) {
            JsonObject o = asObject(v);

            String start = str(o, "startTimeUnixNano");
            if (start == null) start = str(o, "start_time_unix_nano");

            String time = str(o, "timeUnixNano");
            if (time == null) time = str(o, "time_unix_nano");

            Integer count = integer(o, "count");
            Double sum = dbl(o, "sum");
            Double min = dbl(o, "min");
            Double max = dbl(o, "max");

            JsonArray bucketCountsArr = arr(o, "bucketCounts");
            if (bucketCountsArr == null) bucketCountsArr = arr(o, "bucket_counts");

            JsonArray explicitBoundsArr = arr(o, "explicitBounds");
            if (explicitBoundsArr == null) explicitBoundsArr = arr(o, "explicit_bounds");

            List<String> bucketCounts = stringList(bucketCountsArr);
            List<Double> explicitBounds = doubleList(explicitBoundsArr);

            Map<String, MetricsEnvelope.AnyValue> attrs = parseAttributesMap(arr(o, "attributes"));

            out.add(new MetricsEnvelopeImpl.HistogramDataPointImpl(
                    start, time, count, sum, min, max, bucketCounts, explicitBounds, attrs
            ));
        }

        return List.copyOf(out);
    }

    /**
     * Turns OTLP attribute array:
     *   [{"key":"k1","value":{...}}, {"key":"k2","value":{...}}]
     * into a Map: k1 -> AnyValue, k2 -> AnyValue
     */
    private Map<String, MetricsEnvelope.AnyValue> parseAttributesMap(JsonArray a) {
        if (a == null) return Map.of();

        Map<String, MetricsEnvelope.AnyValue> out = new LinkedHashMap<>();
        for (JsonValue v : a) {
            JsonObject o = asObject(v);
            String key = str(o, "key");
            MetricsEnvelope.AnyValue value = parseAnyValue(obj(o, "value"));

            // If key is null/blank, skip to avoid confusing map entries
            if (key == null || key.isBlank()) continue;

            // If duplicates occur, last-write-wins (common/simple policy)
            out.put(key, value);
        }
        return out.isEmpty() ? Map.of() : Map.copyOf(out);
    }

    private MetricsEnvelope.AnyValue parseAnyValue(JsonObject v) {
        if (v == null) return new MetricsEnvelopeImpl.AnyValueImpl(null, null, null, null, Map.of());

        String stringValue = v.containsKey("stringValue") ? str(v, "stringValue") : null;

        String intValue = null;
        if (v.containsKey("intValue")) {
            JsonValue iv = v.get("intValue");
            intValue = switch (iv.getValueType()) {
                case STRING -> ((JsonString) iv).getString();
                case NUMBER -> ((JsonNumber) iv).toString();
                default -> null;
            };
        }

        Double doubleValue = null;
        if (v.containsKey("doubleValue")) {
            JsonValue dv = v.get("doubleValue");
            if (dv.getValueType() == JsonValue.ValueType.NUMBER) {
                doubleValue = ((JsonNumber) dv).doubleValue();
            } else if (dv.getValueType() == JsonValue.ValueType.STRING) {
                try { doubleValue = Double.parseDouble(((JsonString) dv).getString()); }
                catch (NumberFormatException ignored) { }
            }
        }

        Boolean boolValue = null;
        if (v.containsKey("boolValue")) {
            JsonValue bv = v.get("boolValue");
            boolValue = switch (bv.getValueType()) {
                case TRUE -> Boolean.TRUE;
                case FALSE -> Boolean.FALSE;
                default -> null;
            };
        }

        Map<String, Object> raw = jsonObjectToMap(v);
        return new MetricsEnvelopeImpl.AnyValueImpl(stringValue, intValue, doubleValue, boolValue, raw);
    }

    // ---- JSON-P helpers ----

    private static JsonObject asObject(JsonValue v) {
        if (v == null || v.getValueType() != JsonValue.ValueType.OBJECT) {
            throw new IllegalArgumentException("Expected JSON object but got: " + (v == null ? "null" : v.getValueType()));
        }
        return v.asJsonObject();
    }

    private static JsonObject obj(JsonObject o, String key) {
        if (o == null || !o.containsKey(key) || o.isNull(key)) return null;
        JsonValue v = o.get(key);
        return v.getValueType() == JsonValue.ValueType.OBJECT ? o.getJsonObject(key) : null;
    }

    private static JsonArray arr(JsonObject o, String key) {
        if (o == null || !o.containsKey(key) || o.isNull(key)) return null;
        JsonValue v = o.get(key);
        return v.getValueType() == JsonValue.ValueType.ARRAY ? o.getJsonArray(key) : null;
    }

    private static String str(JsonObject o, String key) {
        if (o == null || !o.containsKey(key) || o.isNull(key)) return null;
        JsonValue v = o.get(key);
        return v.getValueType() == JsonValue.ValueType.STRING ? o.getString(key) : v.toString();
    }

    private static Integer integer(JsonObject o, String key) {
        if (o == null || !o.containsKey(key) || o.isNull(key)) return null;
        JsonValue v = o.get(key);
        if (v.getValueType() == JsonValue.ValueType.NUMBER) return o.getJsonNumber(key).intValue();
        if (v.getValueType() == JsonValue.ValueType.STRING) {
            try { return Integer.parseInt(o.getString(key)); } catch (NumberFormatException ignored) { }
        }
        return null;
    }

    private static Double dbl(JsonObject o, String key) {
        if (o == null || !o.containsKey(key) || o.isNull(key)) return null;
        JsonValue v = o.get(key);
        if (v.getValueType() == JsonValue.ValueType.NUMBER) return o.getJsonNumber(key).doubleValue();
        if (v.getValueType() == JsonValue.ValueType.STRING) {
            try { return Double.parseDouble(o.getString(key)); } catch (NumberFormatException ignored) { }
        }
        return null;
    }

    private static List<String> stringList(JsonArray a) {
        if (a == null) return List.of();
        List<String> out = new ArrayList<>(a.size());
        for (JsonValue v : a) {
            out.add(v.getValueType() == JsonValue.ValueType.STRING ? ((JsonString) v).getString() : v.toString());
        }
        return List.copyOf(out);
    }

    private static List<Double> doubleList(JsonArray a) {
        if (a == null) return List.of();
        List<Double> out = new ArrayList<>(a.size());
        for (JsonValue v : a) {
            if (v.getValueType() == JsonValue.ValueType.NUMBER) {
                out.add(((JsonNumber) v).doubleValue());
            } else if (v.getValueType() == JsonValue.ValueType.STRING) {
                try { out.add(Double.parseDouble(((JsonString) v).getString())); }
                catch (NumberFormatException ignored) { }
            }
        }
        return List.copyOf(out);
    }

    // ---- missing methods (now included) ----

    private static Map<String, Object> jsonObjectToMap(JsonObject o) {
        Map<String, Object> m = new LinkedHashMap<>();
        for (Map.Entry<String, JsonValue> e : o.entrySet()) {
            m.put(e.getKey(), toJava(e.getValue()));
        }
        return m;
    }

    private static Object toJava(JsonValue v) {
        return switch (v.getValueType()) {
            case NULL -> null;
            case TRUE -> Boolean.TRUE;
            case FALSE -> Boolean.FALSE;
            case STRING -> ((JsonString) v).getString();
            case NUMBER -> {
                JsonNumber n = (JsonNumber) v;
                if (n.isIntegral()) yield n.longValue();
                yield n.bigDecimalValue();
            }
            case ARRAY -> {
                JsonArray a = (JsonArray) v;
                List<Object> out = new ArrayList<>(a.size());
                for (JsonValue x : a) out.add(toJava(x));
                yield List.copyOf(out);
            }
            case OBJECT -> jsonObjectToMap((JsonObject) v);
        };
    }
}