<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>PR.html</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

</head>

<body>

<h1 id="discovery">Discovery</h1>
<h2 id="summary">Summary</h2>
<p>Discovery is defined to be the transformation of a <dfn>discovery
name</dfn> supplied at runtime into an immutable, non-determinate set of
<dfn>discovered resources</dfn>, such as URIs, that it notionally
describes at a given moment in time.</p>
<p>Helidon offers the Discovery feature as a Java API backed by
potentially many implementations.</p>
<p>It is anticipated that the API will be used primarily by future
Helidon integrations and enhancements. The API may also be used directly
by a Helidon user.</p>
<h2 id="use-cases">Use Cases</h2>
<p>The Discovery API is a manifestation of the following abstract use
cases, possibly among others.</p>
<h3 id="basic">Basic</h3>
<ol type="1">
<li>A developer or subsystem asks Helidon for an implementation of
Discovery without necessarily knowing in advance what implementation
will be supplied.</li>
<li>Helidon provides such a Discovery.</li>
<li>The developer or subsystem asks Discovery for a set of
<dfn>discovered URIs</dfn>, possibly also bearing metadata,
corresponding to a <dfn>discovery name</dfn>.</li>
<li>The Discovery implementation provides such a set.
<ol type="1">
<li>If the provided set is empty or Discovery encounters a problem, the
developer or subsystem uses a default value instead or stops the
application, as appropriate.</li>
</ol></li>
<li>The developer or subsystem selects an element from the provided set
for use according to the application’s requirements and heuristics.</li>
<li>The developer or subsystem uses the URI the selected element
represents in subsequent development.</li>
</ol>
<h3 id="testing">Testing</h3>
<ol type="1">
<li>A developer wishes to test a part of her application that happens to
use the Discovery API (a Discovery-using component).
<ol type="1">
<li>This Discovery API usage may not be, itself, under test.</li>
</ol></li>
<li>She ensures that a Discovery implementation is present in her
project’s runtime (and hence test) dependencies.</li>
<li>She configures this Discovery implementation to be disabled at test
time.
<ol type="1">
<li>Note that this implies any Discovery implementation may be so
configured.</li>
</ol></li>
<li>She executes the test.</li>
<li>The Discovery-using component is, by definition, prepared for a
Discovery implementation to be disabled.
<ol type="a">
<li>For example, depending on the final shape of the Discovery API, it
might supply a default value at discovery time, or it might test the
discovered set to see if it is empty before using a default value
instead.</li>
</ol></li>
<li>The disabled-at-test-time Discovery implementation returns an empty
discovered set, because it was disabled by the developer.</li>
<li>The Discovery-using component is prepared for this case and uses a
default value instead (see (5a.)).</li>
<li>The test runs successfully, with “real” Discovery never actually
being performed.</li>
</ol>
<h2 id="requirements">Requirements</h2>
<p>The Discovery API is a manifestation of the following requirements,
possibly among others. Because these are requirements of the API, they
are also requirements of all implementations.</p>
<ol type="1">
<li>Discovery is fundamentally a Java API that provides a set of
possibly metadata-bearing, discovered URIs when given a <dfn>discovery
name</dfn>. This is the <dfn>discovered set</dfn>.</li>
<li>Discovery names should be composed only from legal DNS name
characters, since DNS-based Discovery implementations are possible. In
practice this means alphabetic characters, digits, “.”, and “-”.</li>
<li>There must be no restriction on the schemes of URIs used by
Discovery (http, https, jdbc, amqp, etc.).</li>
<li>A URI represented by an element in the discovered set may be used
for any purpose by the caller.</li>
<li>The discovered set must be immutable.</li>
<li>The discovered set may be empty, depending on the final API.
<ol type="a">
<li>For example, an API that accepts a default value may end up
requiring the default value’s presence in the discovered set.</li>
</ol></li>
<li>Any two retrievals may result in discovered sets with different
elements.</li>
<li>Any two retrievals may result in identical discovered sets.</li>
<li>Discovery must permit multiple implementations (Eureka, Consul,
Kubernetes, etc.).</li>
<li>The presence of two or more enabled Discovery implementations at
runtime in an application is prohibited.</li>
<li>Discovered set order may or may not be significant, depending on the
Discovery implementation.</li>
<li>No guarantees exist or can be made about the health or availability
of an application described by a URI represented by an element of the
provided set.</li>
<li>Any malfunctioning of a Discovery implementation must not prevent an
application from continuing.</li>
<li>Discovery must be <dfn>opt-in</dfn>, not <dfn>opt-out</dfn>.
Specifically:
<ol type="1">
<li>Discovery may be used explicitly, i.e. by a developer making method
calls in a Discovery API and then making use of the discovered set of
discovered URIs she receives.</li>
<li>In certain Helidon integration use cases, Discovery may be used
implicitly, i.e. by a facility in Helidon that can apply Discovery
automatically, but there must be some developer-visible manifestation of
Discovery in such a case so that Discovery remains opt-in and its
effects can be anticipated.</li>
</ol></li>
<li>Discovery must not be used to find or connect to an implementation
of Discovery.</li>
</ol>

</body>
</html>
